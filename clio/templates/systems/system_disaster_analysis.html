{% extends "base.html" %}

{% block title %}Disaster Impact Analysis - {{ system.name }} - Clio{% endblock %}

{% block extra_css %}
<style>
    /* Base styling for impact badges */
    .impact-badge {
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
    }
    
    .impact-badge-primary {
        background-color: #fee2e2;
        color: #b91c1c;
    }
    
    .impact-badge-secondary {
        background-color: #ffedd5;
        color: #c2410c;
    }
    
    .impact-badge-tertiary {
        background-color: #fef9c3;
        color: #854d0e;
    }
    
    .impact-badge-quaternary {
        background-color: #e0f2fe;
        color: #0369a1;
    }
    
    /* Graph visualization styles */
    #diagram-container {
        position: relative;
        width: 100%;
        height: 600px;
        margin-bottom: 20px;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        overflow: hidden;
    }
    
    #disaster-graph {
        width: 100%;
        height: 100%;
        background-color: #f9fafb;
    }
    
    .system-node {
        stroke-width: 2px;
        cursor: pointer;
    }
    
    .system-label {
        font-size: 10px;
        text-anchor: middle;
        pointer-events: none;
        font-weight: normal;
    }
    
    .main-system .system-label {
        font-weight: bold;
    }
    
    .label-background {
        fill: white;
        fill-opacity: 0.8;
        stroke: #ddd;
        stroke-width: 0.5;
    }
    
    .connection {
        stroke: #999;
        stroke-width: 1.5px;
        fill: none;
        marker-end: url(#arrowhead);
    }
    
    .connection-direct {
        stroke-dasharray: none;
    }
    
    .connection-sso {
        stroke-dasharray: 5, 3;
    }
    
    .connection-hosting {
        stroke-dasharray: 1, 3;
    }
    
    .connection-highlighted {
        stroke: #ff5722;
        stroke-width: 2.5px;
    }
    
    .highlighted {
        stroke-width: 3px;
        stroke: #ff5722;
    }

    /* Legend styling */
    .legend {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        flex-direction: column;
        padding: 8px;
        background-color: white;
        border-radius: 4px;
        border: 1px solid #e5e7eb;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        z-index: 10;
        max-width: 180px;
    }
    
    .legend-title {
        font-weight: 600;
        margin-bottom: 8px;
        border-bottom: 1px solid #eee;
        padding-bottom: 5px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 4px;
    }
    
    .legend-color {
        width: 12px;
        height: 12px;
        margin-right: 8px;
        border-radius: 3px;
    }
    
    /* Info panel styling */
    #infoPanel {
        position: absolute;
        bottom: 20px;
        left: 20px;
        background-color: white;
        border: 1px solid #ddd;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        max-width: 300px;
        display: none;
        z-index: 10;
        max-height: 400px;
        overflow-y: auto;
    }
    
    /* Zoom controls */
    .zoom-controls {
        position: absolute;
        right: 20px;
        top: 160px;
        background-color: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12);
        z-index: 10;
    }
    
    .zoom-controls button {
        display: block;
        width: 34px;
        height: 34px;
        background-color: white;
        border: none;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        font-size: 18px;
        padding: 0;
        text-align: center;
    }
    
    .zoom-controls button:last-child {
        border-bottom: none;
    }
    
    .zoom-controls button:hover {
        background-color: #f5f5f5;
    }
    
    /* Loading indicator */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        font-size: 18px;
        font-weight: bold;
        color: #4285f4;
    }
    
    .spinner {
        display: inline-block;
        width: 24px;
        height: 24px;
        border: 3px solid rgba(66, 133, 244, 0.3);
        border-radius: 50%;
        border-top-color: #4285f4;
        animation: spin 1s ease-in-out infinite;
        margin-right: 10px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    /* Path visualization */
    .failure-path {
        stroke: #ef4444;
        stroke-width: 3px;
        fill: none;
        stroke-dasharray: none;
        pointer-events: none;
        stroke-linecap: round;
        animation: pathPulse 2s infinite;
    }
    
    @keyframes pathPulse {
        0% { stroke-opacity: 1; }
        50% { stroke-opacity: 0.6; }
        100% { stroke-opacity: 1; }
    }
    
    /* Better empty state */
    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 3rem;
        text-align: center;
    }
    
    .empty-state svg {
        color: #9ca3af;
        margin-bottom: 1rem;
    }
    
    /* Controls panel */
    .controls-panel {
        margin-bottom: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }
    
    .control-button {
        padding: 0.5rem 1rem;
        background-color: white;
        border: 1px solid #e5e7eb;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        color: #374151;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
    }
    
    .control-button:hover {
        background-color: #f9fafb;
    }
    
    .control-button.active {
        background-color: #ef4444;
        border-color: #dc2626;
        color: white;
    }
    
    /* Recovery step styling */
    .recovery-step {
        position: relative;
        border-left: 4px solid #3b82f6;
        padding-left: 1.5rem;
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
    }
    
    .recovery-step-number {
        position: absolute;
        left: -1.25rem;
        top: -0.25rem;
        height: 2.5rem;
        width: 2.5rem;
        background-color: #3b82f6;
        border-radius: 9999px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 600;
        font-size: 0.875rem;
    }
    
    /* Node pulsing animation */
    @keyframes pulse-node {
        0% { stroke-width: 2px; r: attr(data-original-r px); }
        50% { stroke-width: 3px; r: calc(attr(data-original-r px) * 1.2); }
        100% { stroke-width: 2px; r: attr(data-original-r px); }
    }
    
    .pulse-animation {
        animation: pulse-node 2s infinite;
    }
    
    /* Path chain visualization styles */
    .impact-path {
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
        overflow: hidden;
    }
    
    .impact-path-header {
        padding: 0.75rem 1rem;
        font-weight: 600;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .path-header-primary {
        background-color: #fee2e2;
        color: #b91c1c;
    }
    
    .path-header-secondary {
        background-color: #ffedd5;
        color: #c2410c;
    }
    
    .path-header-tertiary {
        background-color: #fef9c3;
        color: #854d0e;
    }
    
    .path-header-quaternary {
        background-color: #e0f2fe;
        color: #0369a1;
    }
    
    .impact-path-body {
        padding: 1rem;
        background-color: white;
    }
    
    .dependency-chain {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .chain-node {
        padding: 0.25rem 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.75rem;
        margin-right: 0.5rem;
        white-space: nowrap;
        font-weight: 500;
    }
    
    .chain-arrow {
        margin: 0 0.25rem;
        color: #9ca3af;
    }
    
    .connection-type-badge {
        font-size: 0.625rem;
        padding: 0.125rem 0.25rem;
        border-radius: 0.25rem;
        margin-left: 0.25rem;
        vertical-align: top;
    }
    
    .connection-direct-badge {
        background-color: #e5e7eb;
        color: #4b5563;
    }
    
    .connection-sso-badge {
        background-color: #dbeafe;
        color: #1d4ed8;
    }
    
    .connection-hosting-badge {
        background-color: #f3e8ff;
        color: #7e22ce;
    }
    
    /* Dependency path filter */
    .path-filter-control {
        margin-bottom: 1rem;
        padding: 0.75rem;
        background-color: #f3f4f6;
        border-radius: 0.5rem;
    }
    
    /* Collapsible sections */
    .collapse-trigger {
        cursor: pointer;
    }
    
    .collapse-trigger svg {
        transition: transform 0.2s;
    }
    
    .collapse-trigger.collapsed svg {
        transform: rotate(-90deg);
    }
    
    .collapsible-content {
        transition: max-height 0.3s ease-out;
        max-height: 2000px;
        overflow: hidden;
    }
    
    .collapsible-content.collapsed {
        max-height: 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 640px) {
        #diagram-container {
            height: 400px;
        }
        
        .legend {
            max-width: 140px;
            font-size: 0.75rem;
        }
        
        #infoPanel {
            max-width: 250px;
        }
        
        .dependency-chain {
            flex-direction: column;
            align-items: flex-start;
        }
        
        .chain-node {
            margin-bottom: 0.5rem;
        }
        
        .chain-arrow {
            transform: rotate(90deg);
            margin: 0.25rem 0;
        }
    }
</style>
{% endblock %}

{% block page_header %}
<div class="md:flex md:items-center md:justify-between">
    <div class="flex-1 min-w-0">
        <h2 class="text-2xl font-bold leading-7 text-gray-900 sm:text-3xl sm:truncate">
            Disaster Impact Analysis: {{ system.name }}
        </h2>
        <div class="mt-1 flex flex-col sm:flex-row sm:flex-wrap sm:mt-0 sm:space-x-6">
            <div class="mt-2 flex items-center text-sm text-gray-500">
                <span class="px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full"
                      style="background-color: {{ system.category.color }}; color: {{ system.category.text_color }}">
                    {{ system.category.name }}
                </span>
            </div>
            <div class="mt-2 flex items-center text-sm text-gray-500">
                <span class="px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full"
                      style="background-color: {{ system.status.color }}; color: {{ system.status.text_color }}">
                    {{ system.status.name }}
                </span>
            </div>
        </div>
    </div>
    <div class="mt-4 flex md:mt-0 md:ml-4">
        <button id="runDisasterSimulation" class="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            Run Simulation
        </button>
        <a href="{% url 'systems:detail' system.id %}" class="ml-3 inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
            Back to System
        </a>
    </div>
</div>
{% endblock %}

{% block content %}
<div class="bg-white shadow overflow-hidden sm:rounded-lg">
    <div class="px-4 py-5 sm:px-6 bg-amber-50">
        <div class="flex items-start">
            <div class="flex-shrink-0">
                <svg class="h-6 w-6 text-amber-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                </svg>
            </div>
            <div class="ml-3">
                <h3 class="text-md leading-6 font-medium text-gray-900">
                    Failure Impact Assessment
                </h3>
                <p class="mt-1 text-sm text-gray-500">
                    This analysis shows the cascading impact of a failure in {{ system.name }}. The visualization displays dependency relationships and failure propagation paths.
                </p>
            </div>
        </div>
    </div>
    
    <div class="border-t border-gray-200">
        <div id="disaster-simulation-results" class="px-4 py-5 sm:p-6 hidden">
            <div class="mb-6">
                <div class="flex items-center justify-between">
                    <h3 class="text-base font-medium text-gray-900">Impact Summary</h3>
                    <span id="total-affected-count" class="px-2 py-1 text-xs font-semibold rounded-full bg-red-100 text-red-800"></span>
                </div>
                <div class="mt-2">
                    <div class="w-full bg-gray-200 rounded-full h-2.5">
                        <div id="impact-progress" class="bg-red-600 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            
            <!-- Visualization controls -->
            <div class="controls-panel">
                <button type="button" id="resetViewButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Reset View
                </button>
                <button type="button" id="optimizeLayoutButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
                    </svg>
                    Optimize Layout
                </button>
                <button type="button" id="showFullPathButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
                    </svg>
                    Show Full Paths
                </button>
                <button type="button" id="toggleIntermediateButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
                    </svg>
                    Hide Intermediate
                </button>
                <button type="button" id="toggleHostingButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" />
                    </svg>
                    Show Hosting
                </button>
                <button type="button" id="toggleSsoButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                    </svg>
                    Show SSO
                </button>
                <button type="button" id="showImmediateImpactsButton" class="control-button">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                    Focus on Direct
                </button>
            </div>
            
            <!-- Dependency Graph Visualization -->
            <div id="diagram-container" style="width: 100%; min-height: 600px;">
                <div id="disaster-graph"></div>
                
                <!-- Legend -->
                <div class="legend">
                    <div class="legend-title">Impact Legend</div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffd700; border: 1px solid #ff8c00;"></div>
                        <span>Current System</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fee2e2; border: 1px solid #ef4444;"></div>
                        <span>Primary Impact</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffedd5; border: 1px solid #f97316;"></div>
                        <span>Secondary Impact</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #fef9c3; border: 1px solid #eab308;"></div>
                        <span>Tertiary Impact</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #dbeafe; border: 1px solid #60a5fa;"></div>
                        <span>Distant Impact (4+)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #e0f2fe; border: 1px solid #0ea5e9;"></div>
                        <span>SSO Dependency</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #f3e8ff; border: 1px solid #a855f7;"></div>
                        <span>Hosting Dependency</span>
                    </div>
                </div>
                
                <!-- Zoom controls -->
                <div class="zoom-controls">
                    <button id="zoomInButton" title="Zoom In">+</button>
                    <button id="zoomOutButton" title="Zoom Out">−</button>
                    <button id="fitViewButton" title="Fit All">⌂</button>
                </div>
                
                <!-- Info panel -->
                <div id="infoPanel">
                    <h3 id="infoPanelTitle" class="text-lg font-medium mb-2"></h3>
                    <div id="infoPanelContent"></div>
                </div>
                
                <!-- Loading overlay -->
                <div class="loading-overlay">
                    <div class="spinner"></div>
                    <span>Analyzing failure impact...</span>
                </div>
            </div>
            
            <!-- Impact Metrics -->
            <div class="mt-8 grid grid-cols-1 gap-5 sm:grid-cols-4">
                <div class="bg-white overflow-hidden shadow rounded-lg">
                    <div class="px-4 py-5 sm:p-6">
                        <dl>
                            <dt class="text-sm font-medium text-gray-500 truncate">
                                Systems Affected
                            </dt>
                            <dd id="systems-affected" class="mt-1 text-3xl font-semibold text-gray-900">
                                --
                            </dd>
                        </dl>
                    </div>
                </div>
                
                <div class="bg-white overflow-hidden shadow rounded-lg">
                    <div class="px-4 py-5 sm:p-6">
                        <dl>
                            <dt class="text-sm font-medium text-gray-500 truncate">
                                Estimated Recovery Time
                            </dt>
                            <dd id="recovery-time" class="mt-1 text-3xl font-semibold text-gray-900">
                                --
                            </dd>
                        </dl>
                    </div>
                </div>
                
                <div class="bg-white overflow-hidden shadow rounded-lg">
                    <div class="px-4 py-5 sm:p-6">
                        <dl>
                            <dt class="text-sm font-medium text-gray-500 truncate">
                                User Impact Estimate
                            </dt>
                            <dd id="user-impact" class="mt-1 text-3xl font-semibold text-gray-900">
                                --
                            </dd>
                        </dl>
                    </div>
                </div>
                
                <div class="bg-white overflow-hidden shadow rounded-lg">
                    <div class="px-4 py-5 sm:p-6">
                        <dl>
                            <dt class="text-sm font-medium text-gray-500 truncate">
                                Business Impact
                            </dt>
                            <dd id="business-impact" class="mt-1 text-3xl font-semibold text-gray-900">
                                --
                            </dd>
                        </dl>
                    </div>
                </div>
            </div>
            
            <!-- NEW: Complete Downstream Impact Paths -->
            <div class="mt-8">
                <div class="flex items-center justify-between mb-4 collapse-trigger" id="impactPathsHeader">
                    <h3 class="text-lg font-medium text-gray-900 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                        Complete Downstream Impact Paths
                    </h3>
                    <span class="text-sm text-gray-500" id="totalPathsCount">0 paths identified</span>
                </div>
                
                <div class="collapsible-content" id="impactPathsContent">
                    <!-- Path filter options -->
                    <div class="path-filter-control">
                        <div class="flex flex-wrap gap-4 items-center">
                            <div>
                                <label for="pathTypeFilter" class="block text-sm font-medium text-gray-700 mb-1">Filter by impact level:</label>
                                <select id="pathTypeFilter" class="mt-1 block w-full pl-3 pr-10 py-2 text-sm border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 rounded-md">
                                    <option value="all">All Impact Levels</option>
                                    <option value="primary">Primary Impact</option>
                                    <option value="secondary">Secondary Impact</option>
                                    <option value="tertiary">Tertiary Impact</option>
                                    <option value="quaternary">Distant Impact (4+)</option>
                                </select>
                            </div>
                            
                            <div>
                                <label for="pathSortOrder" class="block text-sm font-medium text-gray-700 mb-1">Sort by:</label>
                                <select id="pathSortOrder" class="mt-1 block w-full pl-3 pr-10 py-2 text-sm border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 rounded-md">
                                    <option value="impact">Impact Score (Highest First)</option>
                                    <option value="path-length">Path Length (Shortest First)</option>
                                    <option value="alphabetical">System Name (A-Z)</option>
                                </select>
                            </div>
                            
                            <div>
                                <label for="connectionTypeFilter" class="block text-sm font-medium text-gray-700 mb-1">Connection types:</label>
                                <div class="flex items-center gap-3 mt-2">
                                    <label class="inline-flex items-center">
                                        <input type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" id="showDirectConnections" checked>
                                        <span class="ml-2 text-sm text-gray-700">Direct</span>
                                    </label>
                                    <label class="inline-flex items-center">
                                        <input type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" id="showSSOConnections" checked>
                                        <span class="ml-2 text-sm text-gray-700">SSO</span>
                                    </label>
                                    <label class="inline-flex items-center">
                                        <input type="checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" id="showHostingConnections" checked>
                                        <span class="ml-2 text-sm text-gray-700">Hosting</span>
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Impact paths container -->
                    <div id="impact-paths-container" class="mt-4 space-y-4">
                        <!-- Will be populated by JavaScript -->
                        <div class="empty-state py-8">
                            <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                            <h3 class="mt-2 text-sm font-medium text-gray-900">Run the simulation to see complete impact paths</h3>
                            <p class="mt-1 text-sm text-gray-500">
                                Failure paths will be displayed here after running the impact analysis.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Impact Lists -->
            <div class="mt-8">
                <div class="flex items-center justify-between mb-4 collapse-trigger" id="impactBreakdownHeader">
                    <h3 class="text-lg font-medium text-gray-900 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                        </svg>
                        Impact Breakdown
                    </h3>
                </div>
                
                <div class="collapsible-content" id="impactBreakdownContent">
                    <div class="grid grid-cols-1 gap-6 lg:grid-cols-3">
                        <!-- Primary Impact (Tier 1) -->
                        <div class="bg-white shadow overflow-hidden sm:rounded-lg">
                            <div class="px-4 py-5 sm:px-6 bg-red-50">
                                <h4 class="text-base font-medium text-red-700 flex items-center">
                                    <span class="inline-block w-3 h-3 bg-red-700 rounded-full mr-2"></span>
                                    Primary Impact Systems
                                </h4>
                            </div>
                            <div class="border-t border-gray-200">
                                <div id="primary-impact-systems" class="divide-y divide-gray-200">
                                    <!-- Will be populated by JavaScript -->
                                    <div class="p-4 text-sm text-gray-500 text-center">No systems found</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Secondary Impact (Tier 2) -->
                        <div class="bg-white shadow overflow-hidden sm:rounded-lg">
                            <div class="px-4 py-5 sm:px-6 bg-orange-50">
                                <h4 class="text-base font-medium text-orange-700 flex items-center">
                                    <span class="inline-block w-3 h-3 bg-orange-600 rounded-full mr-2"></span>
                                    Secondary Impact Systems
                                </h4>
                            </div>
                            <div class="border-t border-gray-200">
                                <div id="secondary-impact-systems" class="divide-y divide-gray-200">
                                    <!-- Will be populated by JavaScript -->
                                    <div class="p-4 text-sm text-gray-500 text-center">No systems found</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Tertiary Impact (Tier 3) -->
                        <div class="bg-white shadow overflow-hidden sm:rounded-lg">
                            <div class="px-4 py-5 sm:px-6 bg-yellow-50">
                                <h4 class="text-base font-medium text-yellow-700 flex items-center">
                                    <span class="inline-block w-3 h-3 bg-yellow-600 rounded-full mr-2"></span>
                                    Tertiary Impact Systems
                                </h4>
                            </div>
                            <div class="border-t border-gray-200">
                                <div id="tertiary-impact-systems" class="divide-y divide-gray-200">
                                    <!-- Will be populated by JavaScript -->
                                    <div class="p-4 text-sm text-gray-500 text-center">No systems found</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="disaster-simulation-placeholder" class="px-4 py-12 sm:p-6 text-center">
            <div class="empty-state">
                <svg class="h-12 w-12" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <h3 class="mt-2 text-sm font-medium text-gray-900">No simulation results</h3>
                <p class="mt-1 text-sm text-gray-500">
                    Click "Run Simulation" to analyze the potential impact of a failure in this system.
                </p>
                <div class="mt-6">
                    <button type="button" id="runSimulationFromPlaceholder" class="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                        Run Simulation
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Disaster Recovery Plan -->
<div class="mt-6 bg-white shadow overflow-hidden sm:rounded-lg">
    <div class="px-4 py-5 sm:px-6 flex justify-between items-center">
        <div>
            <h4 class="text-md leading-6 font-medium text-gray-900">
                Disaster Recovery Plan
            </h4>
            <p class="mt-1 max-w-2xl text-sm text-gray-500">
                Step-by-step recovery process in case of system failure.
            </p>
        </div>
        <button id="addRecoveryStepBtn" class="inline-flex items-center px-3 py-2 border border-transparent shadow-sm text-sm leading-4 font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700">
            Add Step
        </button>
    </div>
    <div class="border-t border-gray-200 px-4 py-5 sm:px-6">
        <div id="recovery-steps-container" class="space-y-6">
            {% if recovery_steps %}
                {% for step in recovery_steps %}
                <div class="recovery-step relative border-l-4 border-blue-600 pl-4 py-2" data-step-id="{{ step.id }}">
                    <div class="absolute -left-5 -top-1 h-10 w-10 rounded-full bg-blue-600 flex items-center justify-center">
                        <span class="text-xs font-medium text-white">{{ step.order }}</span>
                    </div>
                    <div class="flex justify-between items-start ml-4">
                        <div>
                            <h5 class="text-sm font-medium text-gray-900">{{ step.title }}</h5>
                            <p class="mt-1 text-sm text-gray-500">{{ step.description|linebreaksbr }}</p>
                            
                            {% if step.responsible_team or step.estimated_time %}
                            <div class="mt-2 flex space-x-4 text-xs text-gray-500">
                                {% if step.responsible_team %}
                                <div>
                                    <span class="font-medium">Team:</span> {{ step.responsible_team }}
                                </div>
                                {% endif %}
                                
                                {% if step.estimated_time %}
                                <div>
                                    <span class="font-medium">Est. Time:</span> {{ step.estimated_time }}
                                </div>
                                {% endif %}
                            </div>
                            {% endif %}
                        </div>
                        <div class="flex space-x-2">
                            <button type="button" class="text-blue-600 hover:text-blue-900 edit-step" data-step-id="{{ step.id }}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                </svg>
                            </button>
                            <button type="button" class="text-red-600 hover:text-red-900 delete-step" data-step-id="{{ step.id }}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                </svg>
                            </button>
                            {% if not forloop.first %}
                            <button type="button" class="text-gray-600 hover:text-gray-900 move-step-up" data-step-id="{{ step.id }}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
                                </svg>
                            </button>
                            {% endif %}
                            {% if not forloop.last %}
                            <button type="button" class="text-gray-600 hover:text-gray-900 move-step-down" data-step-id="{{ step.id }}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                                </svg>
                            </button>
                            {% endif %}
                        </div>
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div id="empty-recovery-steps" class="text-center py-8">
                    <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-900">No recovery steps</h3>
                    <p class="mt-1 text-sm text-gray-500">
                        Start by adding the first step to your disaster recovery plan.
                    </p>
                </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Recovery Step Modal -->
<div id="recoveryStepModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4" id="stepModalTitle">Add Recovery Step</h3>
        <form id="recoveryStepForm" method="post" action="{% url 'systems:save_recovery_step' system.id %}">
            {% csrf_token %}
            <input type="hidden" name="step_id" id="stepId" value="">
            
            <div class="mb-4">
                <label for="stepTitle" class="block text-sm font-medium text-gray-700">Title</label>
                <input type="text" id="stepTitle" name="title" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required>
            </div>
            
            <div class="mb-4">
                <label for="stepDescription" class="block text-sm font-medium text-gray-700">Description</label>
                <textarea id="stepDescription" name="description" rows="3" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm" required></textarea>
            </div>
            
            <div class="mb-4">
                <label for="responsibleTeam" class="block text-sm font-medium text-gray-700">Responsible Team</label>
                <input type="text" id="responsibleTeam" name="responsible_team" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm">
            </div>
            
            <div class="mb-4">
                <label for="estimatedTime" class="block text-sm font-medium text-gray-700">Estimated Time</label>
                <input type="text" id="estimatedTime" name="estimated_time" class="mt-1 block w-full border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-sm" placeholder="e.g. 30 minutes, 2 hours">
            </div>
            
            <div class="mt-5 sm:mt-6 flex justify-end space-x-3">
                <button type="button" id="cancelStepModal" class="inline-flex justify-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Cancel
                </button>
                <button type="submit" class="inline-flex justify-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Save
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Delete Step Confirmation Modal -->
<div id="deleteStepModal" class="fixed inset-0 bg-gray-500 bg-opacity-75 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-6">
        <h3 class="text-lg font-medium text-gray-900 mb-4">Remove Recovery Step</h3>
        <p class="text-sm text-gray-500 mb-4">
            Are you sure you want to remove this recovery step from the plan? This action cannot be undone.
        </p>
        <form id="deleteStepForm" method="post" action="{% url 'systems:delete_recovery_step' system.id 0 %}">
            {% csrf_token %}
            <input type="hidden" name="step_id" id="deleteStepId" value="">
            
            <div class="mt-5 sm:mt-6 flex justify-end space-x-3">
                <button type="button" id="cancelDeleteStep" class="inline-flex justify-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                    Cancel
                </button>
                <button type="submit" class="inline-flex justify-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                    Remove
                </button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize variables
    let dependencyGraph = null;
    let impactData = null;
    let simulation = null;
    let zoomInstance = null;
    let showFullPaths = true; // Show all paths by default
    let hideIntermediateNodes = false;
    let showHostingDependencies = true;
    let showSsoDependencies = true;
    let nodes = []; // Global nodes array for reference in utility functions
    let completeImpactPaths = []; // Store complete impact paths
    
    // Get DOM elements
    const runDisasterSimulationBtn = document.getElementById('runDisasterSimulation');
    const runSimulationFromPlaceholderBtn = document.getElementById('runSimulationFromPlaceholder');
    const disasterSimulationResults = document.getElementById('disaster-simulation-results');
    const disasterSimulationPlaceholder = document.getElementById('disaster-simulation-placeholder');
    
    // Collapsible sections
    const impactPathsHeader = document.getElementById('impactPathsHeader');
    const impactPathsContent = document.getElementById('impactPathsContent');
    const impactBreakdownHeader = document.getElementById('impactBreakdownHeader');
    const impactBreakdownContent = document.getElementById('impactBreakdownContent');
    
    // Path filtering elements
    const pathTypeFilter = document.getElementById('pathTypeFilter');
    const pathSortOrder = document.getElementById('pathSortOrder');
    const showDirectConnections = document.getElementById('showDirectConnections');
    const showSSOConnections = document.getElementById('showSSOConnections');
    const showHostingConnections = document.getElementById('showHostingConnections');
    
    // Visualization control buttons
    const resetViewButton = document.getElementById('resetViewButton');
    const optimizeLayoutButton = document.getElementById('optimizeLayoutButton');
    const showFullPathButton = document.getElementById('showFullPathButton');
    const toggleIntermediateButton = document.getElementById('toggleIntermediateButton');
    const toggleHostingButton = document.getElementById('toggleHostingButton');
    const toggleSsoButton = document.getElementById('toggleSsoButton');
    const showImmediateImpactsButton = document.getElementById('showImmediateImpactsButton');
    
    // Zoom control buttons
    const zoomInButton = document.getElementById('zoomInButton');
    const zoomOutButton = document.getElementById('zoomOutButton');
    const fitViewButton = document.getElementById('fitViewButton');
    
    // Recovery step buttons
    const addRecoveryStepBtn = document.getElementById('addRecoveryStepBtn');
    const cancelStepModalBtn = document.getElementById('cancelStepModal');
    const cancelDeleteStepBtn = document.getElementById('cancelDeleteStep');
    
    // Setup collapsible sections
    if (impactPathsHeader) {
        impactPathsHeader.addEventListener('click', function() {
            toggleCollapsible(this, impactPathsContent);
        });
    }
    
    if (impactBreakdownHeader) {
        impactBreakdownHeader.addEventListener('click', function() {
            toggleCollapsible(this, impactBreakdownContent);
        });
    }
    
    function toggleCollapsible(header, content) {
        header.classList.toggle('collapsed');
        content.classList.toggle('collapsed');
        
        // Update the arrow icon
        const arrow = header.querySelector('svg');
        if (header.classList.contains('collapsed')) {
            arrow.style.transform = 'rotate(-90deg)';
        } else {
            arrow.style.transform = 'rotate(0)';
        }
    }
    
    // Add event listeners for path filtering
    if (pathTypeFilter) {
        pathTypeFilter.addEventListener('change', filterImpactPaths);
    }
    
    if (pathSortOrder) {
        pathSortOrder.addEventListener('change', filterImpactPaths);
    }
    
    if (showDirectConnections) {
        showDirectConnections.addEventListener('change', filterImpactPaths);
    }
    
    if (showSSOConnections) {
        showSSOConnections.addEventListener('change', filterImpactPaths);
    }
    
    if (showHostingConnections) {
        showHostingConnections.addEventListener('change', filterImpactPaths);
    }
    
    // Add event listeners
    if (runDisasterSimulationBtn) {
        runDisasterSimulationBtn.addEventListener('click', startSimulation);
    }
    
    if (runSimulationFromPlaceholderBtn) {
        runSimulationFromPlaceholderBtn.addEventListener('click', startSimulation);
    }
    
    if (resetViewButton) {
        resetViewButton.addEventListener('click', resetView);
    }
    
    if (optimizeLayoutButton) {
        optimizeLayoutButton.addEventListener('click', optimizeLayout);
    }
    
    if (showFullPathButton) {
        showFullPathButton.addEventListener('click', toggleFullPath);
        // Initialize as active since showFullPaths is true by default
        showFullPathButton.classList.add('active');
    }
    
    if (toggleIntermediateButton) {
        toggleIntermediateButton.addEventListener('click', toggleIntermediate);
    }
    
    if (toggleHostingButton) {
        toggleHostingButton.addEventListener('click', toggleHosting);
    }
    
    if (toggleSsoButton) {
        toggleSsoButton.addEventListener('click', toggleSso);
    }
    
    if (showImmediateImpactsButton) {
        showImmediateImpactsButton.addEventListener('click', function() {
            this.classList.toggle('active');
            if (this.classList.contains('active')) {
                showImmediateImpacts();
            } else {
                resetView();
            }
        });
    }
    
    if (zoomInButton) {
        zoomInButton.addEventListener('click', zoomIn);
    }
    
    if (zoomOutButton) {
        zoomOutButton.addEventListener('click', zoomOut);
    }
    
    if (fitViewButton) {
        fitViewButton.addEventListener('click', fitAllNodes);
    }
    
    // Recovery step event listeners
    if (addRecoveryStepBtn) {
        addRecoveryStepBtn.addEventListener('click', function() {
            openRecoveryStepModal();
        });
    }
    
    if (cancelStepModalBtn) {
        cancelStepModalBtn.addEventListener('click', function() {
            closeRecoveryStepModal();
        });
    }
    
    if (cancelDeleteStepBtn) {
        cancelDeleteStepBtn.addEventListener('click', function() {
            document.getElementById('deleteStepModal').classList.add('hidden');
        });
    }
    
    // Attach event listeners to dynamic elements
    function attachDynamicEventListeners() {
        // Edit step buttons
        document.querySelectorAll('.edit-step').forEach(function(button) {
            button.addEventListener('click', function() {
                const stepId = this.getAttribute('data-step-id');
                editRecoveryStep(stepId);
            });
        });
        
        // Delete step buttons
        document.querySelectorAll('.delete-step').forEach(function(button) {
            button.addEventListener('click', function() {
                const stepId = this.getAttribute('data-step-id');
                confirmDeleteStep(stepId);
            });
        });
        
        // Move step up buttons
        document.querySelectorAll('.move-step-up').forEach(function(button) {
            button.addEventListener('click', function() {
                const stepId = this.getAttribute('data-step-id');
                moveRecoveryStep(stepId, 'up');
            });
        });
        
        // Move step down buttons
        document.querySelectorAll('.move-step-down').forEach(function(button) {
            button.addEventListener('click', function() {
                const stepId = this.getAttribute('data-step-id');
                moveRecoveryStep(stepId, 'down');
            });
        });
        
        // View path in graph buttons
        document.querySelectorAll('.view-path-btn').forEach(function(button) {
            button.addEventListener('click', function(e) {
                e.preventDefault();
                const pathId = this.getAttribute('data-path-id');
                const targetId = this.getAttribute('data-target-id');
                highlightPathInGraph(pathId, targetId);
            });
        });
    }
    
    // Call this initially to set up existing buttons
    attachDynamicEventListeners();
    
    // Function to start the simulation
    function startSimulation() {
        // Show loading state
        runDisasterSimulationBtn.disabled = true;
        runDisasterSimulationBtn.innerHTML = `
            <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            Running Simulation...
        `;
        
        if (runSimulationFromPlaceholderBtn) {
            runSimulationFromPlaceholderBtn.disabled = true;
            runSimulationFromPlaceholderBtn.innerHTML = `
                <svg class="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Running Simulation...
            `;
        }
        
        // Simulate delay for better UX
        setTimeout(function() {
            performDisasterImpactAnalysis();
            
            // Update UI
            disasterSimulationPlaceholder.style.display = 'none';
            disasterSimulationResults.style.display = 'block';
            const forceReflow = document.body.offsetHeight;
            
            // Reset button
            runDisasterSimulationBtn.disabled = false;
            runDisasterSimulationBtn.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                Run Simulation
            `;
            
            if (runSimulationFromPlaceholderBtn) {
                runSimulationFromPlaceholderBtn.disabled = false;
                runSimulationFromPlaceholderBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                    Run Simulation
                `;
            }
        }, 1000);
    }
    
    // Perform the impact analysis
    function performDisasterImpactAnalysis() {
        console.log("Starting disaster impact analysis...");
        
        // Get current system information
        const systemId = {{ system.id }};
        const systemName = "{{ system.name }}";
        const systemCategory = "{{ system.category.slug }}";
        const systemCategoryName = "{{ system.category.name }}";
        
        // Build a complete dependency graph from the relationship data
        dependencyGraph = buildDependencyGraph();
        
        // Log the dependency graph for debugging
        console.log("Dependency graph built:", dependencyGraph);
        
        // Calculate impact tiers based on dependency graph traversal
        impactData = calculateImpactTiers(systemId, dependencyGraph);
        
        // Generate complete downstream impact paths
        completeImpactPaths = generateCompleteImpactPaths(systemId, dependencyGraph);
        
        // Update the impact summary
        updateImpactSummary(impactData);
        
        // Create the dependency graph visualization
        createDependencyVisualization(systemId, dependencyGraph, impactData);
        
        // Populate the impacted systems by tier
        populateImpactedSystems('primary-impact-systems', impactData.primaryImpact);
        populateImpactedSystems('secondary-impact-systems', impactData.secondaryImpact);
        populateImpactedSystems('tertiary-impact-systems', impactData.tertiaryImpact);
        
        // Populate the complete downstream impact paths
        populateImpactPaths(completeImpactPaths);
        
        // Update recovery metrics
        updateRecoveryMetrics(systemCategory, impactData);
        
        // Show failure paths by default since showFullPaths is true
        setTimeout(showFailurePathsInGraph, 500);
        
        console.log("Disaster impact analysis completed.");
    }
    
    // Build a complete dependency graph from system relationships
    function buildDependencyGraph() {
        console.log("Building dependency graph...");
        
        // Create a graph structure to hold all systems and their relationships
        const graph = {
            nodes: {},         // All system nodes
            dependencies: {},  // Outgoing edges from each node (what this system depends on)
            dependents: {},    // Incoming edges to each node (what depends on this system)
            ssoRelations: {},  // Track SSO relationships
            hostingRelations: {} // Track hosting relationships
        };
        
        // First, add all systems we know about to the graph
        const allSystems = [];
        
        // Add the current system
        const currentSystem = {
            id: {{ system.id }},
            name: "{{ system.name }}",
            category: {
                slug: "{{ system.category.slug }}",
                name: "{{ system.category.name }}",
                color: "{{ system.category.color }}",
                text_color: "{{ system.category.text_color }}"
            },
            status: {
                slug: "{{ system.status.slug }}",
                name: "{{ system.status.name }}",
                color: "{{ system.status.color }}",
                text_color: "{{ system.status.text_color }}"
            },
            vendor: "{{ system.vendor|default:'Unknown' }}"
        };
        
        allSystems.push(currentSystem);
        
        // Add systems from related data
        // This collects all known systems to create a complete graph
        function addSystemToCollection(system) {
            if (!allSystems.some(s => s.id === system.id)) {
                allSystems.push(system);
            }
        }
        
        // Add all systems that this system depends on
        {% for dep in dependencies %}
        addSystemToCollection({
            id: {{ dep.id }},
            name: "{{ dep.name }}",
            category: {
                slug: "{{ dep.category.slug }}",
                name: "{{ dep.category.name }}",
                color: "{{ dep.category.color }}",
                text_color: "{{ dep.category.text_color }}"
            },
            status: {
                slug: "{{ dep.status.slug }}",
                name: "{{ dep.status.name }}",
                color: "{{ dep.status.color }}",
                text_color: "{{ dep.status.text_color }}"
            },
            vendor: "{{ dep.vendor|default:'Unknown' }}"
        });
        {% endfor %}
        
        // Add all systems that depend on this system
        {% for dep in dependents %}
        addSystemToCollection({
            id: {{ dep.id }},
            name: "{{ dep.name }}",
            category: {
                slug: "{{ dep.category.slug }}",
                name: "{{ dep.category.name }}",
                color: "{{ dep.category.color }}",
                text_color: "{{ dep.category.text_color }}"
            },
            status: {
                slug: "{{ dep.status.slug }}",
                name: "{{ dep.status.name }}",
                color: "{{ dep.status.color }}",
                text_color: "{{ dep.status.text_color }}"
            },
            vendor: "{{ dep.vendor|default:'Unknown' }}"
        });
        {% endfor %}
        
        // Add systems from other related collections
        // Add systems from SSO dependents
        {% if sso_dependents %}
        {% for sso_dep in sso_dependents %}
        addSystemToCollection({
            id: {{ sso_dep.id }},
            name: "{{ sso_dep.name }}",
            category: {
                slug: "{{ sso_dep.category.slug }}",
                name: "{{ sso_dep.category.name }}",
                color: "{{ sso_dep.category.color }}",
                text_color: "{{ sso_dep.category.text_color }}"
            },
            status: {
                slug: "{{ sso_dep.status.slug }}",
                name: "{{ sso_dep.status.name }}",
                color: "{{ sso_dep.status.color }}",
                text_color: "{{ sso_dep.status.text_color }}"
            },
            vendor: "{{ sso_dep.vendor|default:'Unknown' }}"
        });
        {% endfor %}
        {% endif %}
        
        // Add systems from hosted systems
        {% if hosted_systems %}
        {% for hosted in hosted_systems %}
        addSystemToCollection({
            id: {{ hosted.id }},
            name: "{{ hosted.name }}",
            category: {
                slug: "{{ hosted.category.slug }}",
                name: "{{ hosted.category.name }}",
                color: "{{ hosted.category.color }}",
                text_color: "{{ hosted.category.text_color }}"
            },
            status: {
                slug: "{{ hosted.status.slug }}",
                name: "{{ hosted.status.name }}",
                color: "{{ hosted.status.color }}",
                text_color: "{{ hosted.status.text_color }}"
            },
            vendor: "{{ hosted.vendor|default:'Unknown' }}"
        });
        {% endfor %}
        {% endif %}
        
        // Add all systems to the graph
        allSystems.forEach(system => {
            graph.nodes[system.id] = system;
            graph.dependencies[system.id] = [];
            graph.dependents[system.id] = [];
        });
        // Add direct dependency relationships
        function addDependencyRelationship(sourceId, targetId, type) {
            // Skip if either node doesn't exist
            if (!graph.nodes[sourceId] || !graph.nodes[targetId]) {
                console.log(`Skipping relationship ${sourceId} -> ${targetId} (node missing)`);
                return;
            }
            
            // IMPORTANT: Correctly representing dependency relationships
            // When sourceId depends on targetId, it means:
            // - sourceId needs targetId to function
            // - If targetId fails, sourceId is impacted
            
            console.log(`Adding relationship: ${sourceId} depends on ${targetId} (type: ${type})`);
            
            // Add dependency: source depends on target
            if (!graph.dependencies[sourceId].includes(targetId)) {
                graph.dependencies[sourceId].push(targetId);
            }
            
            // Add dependent: target is depended on by source
            if (!graph.dependents[targetId].includes(sourceId)) {
                graph.dependents[targetId].push(sourceId);
            }
            
            // Track special relationship types
            if (type === 'sso') {
                graph.ssoRelations[sourceId] = targetId;
            } else if (type === 'hosting') {
                graph.hostingRelations[sourceId] = targetId;
            }
        }
        
        // Add direct dependencies: these systems depend on the current system
        {% for dep in dependents %}
        addDependencyRelationship({{ dep.id }}, {{ system.id }}, 'direct');
        {% endfor %}
        
        // Add direct dependencies: current system depends on these
        {% for dep in dependencies %}
        addDependencyRelationship({{ system.id }}, {{ dep.id }}, 'direct');
        {% endfor %}
        
        // Add SSO and hosting relationships
        {% if system.sso_system %}
        addDependencyRelationship({{ system.id }}, {{ system.sso_system.id }}, 'sso');
        {% endif %}
        
        {% if system.hosting_system %}
        addDependencyRelationship({{ system.id }}, {{ system.hosting_system.id }}, 'hosting');
        {% endif %}
        
        {% if sso_dependents %}
        {% for sso_dep in sso_dependents %}
        addDependencyRelationship({{ sso_dep.id }}, {{ system.id }}, 'sso');
        {% endfor %}
        {% endif %}
        
        {% if hosted_systems %}
        {% for hosted in hosted_systems %}
        addDependencyRelationship({{ hosted.id }}, {{ system.id }}, 'hosting');
        {% endfor %}
        {% endif %}
        
        return graph;
    }
    
    // Calculate impact tiers based on the dependency graph
    function calculateImpactTiers(systemId, dependencyGraph) {
        console.log("Calculating impact tiers for system ID:", systemId);
        
        // Use more explicit naming to avoid confusion about what the arrays contain
        const directImpactSystems = []; // Primary (level 1)
        const secondLevelImpactSystems = []; // Secondary (level 2)
        const thirdLevelImpactSystems = []; // Tertiary (level 3)
        const distantImpactSystems = []; // Quaternary+ (level 4+)
        
        // Track visited nodes to prevent duplicates and cycles
        const visitedNodes = new Set([systemId]); // Mark the source system as visited
        
        // Track overall impact score
        let criticalityScore = 0;
        
        // Using BFS to traverse the graph level by level
        // Queue structure: [{id: systemId, level: 0, path: [systemId], sourceNode: null}]
        const queue = [{id: systemId, level: 0, path: [systemId], sourceNode: null}];
        
        // Process all nodes in the queue
        while (queue.length > 0) {
            const { id, level, path, sourceNode } = queue.shift();
            
            // DEBUG: Log each node being processed
            console.log(`Processing node ${id} at level ${level}, via ${sourceNode || "root"}`);
            
            if (level > 0) {
                // This is not the source system
                // Create impact data for this system
                const system = dependencyGraph.nodes[id];
                if (!system) {
                    console.log(`WARNING: Missing node data for system ${id}`);
                    continue;
                }
                
                // Calculate impact score with diminishing factor by level
                const tierFactor = Math.max(0.1, 1 - (level * 0.2));
                const impact = calculateSystemImpact(system, tierFactor);
                
                // Determine connection type
                const connectionType = getConnectionType(sourceNode, id, dependencyGraph);
                
                // Create the impact data
                const impactData = {
                    ...system,
                    impact,
                    impactLevel: getImpactLevelName(level),
                    distanceFromSource: level,
                    connectionType: connectionType,
                    sourceNode: sourceNode,
                    path: path
                };
                
                // Add to appropriate impact array based on level
                if (level === 1) {
                    directImpactSystems.push(impactData);
                    criticalityScore += impact;
                } else if (level === 2) {
                    secondLevelImpactSystems.push(impactData);
                    criticalityScore += impact * 0.7;
                } else if (level === 3) {
                    thirdLevelImpactSystems.push(impactData);
                    criticalityScore += impact * 0.5;
                } else {
                    distantImpactSystems.push(impactData);
                    criticalityScore += impact * 0.3;
                }
            }
            
            // CRITICAL PART: Get systems that are DEPENDENT on this one
            // These are the systems that will be affected if this system fails
            const dependentIds = dependencyGraph.dependents[id] || [];
            console.log(`Node ${id} has ${dependentIds.length} dependents: ${dependentIds.join(', ')}`);
            
            // Process each dependent
            for (const dependentId of dependentIds) {
                // Skip if already visited to avoid cycles
                if (visitedNodes.has(dependentId)) {
                    console.log(`Skipping already visited node ${dependentId}`);
                    continue;
                }
                
                // Mark as visited to avoid reprocessing
                visitedNodes.add(dependentId);
                
                // Add to queue for processing at next level
                queue.push({
                    id: dependentId,
                    level: level + 1,
                    path: [...path, dependentId],
                    sourceNode: id
                });
                
                console.log(`Added node ${dependentId} to queue at level ${level + 1} via ${id}`);
            }
        }
        
        // Sort each tier by impact score (descending)
        directImpactSystems.sort((a, b) => b.impact - a.impact);
        secondLevelImpactSystems.sort((a, b) => b.impact - a.impact);
        thirdLevelImpactSystems.sort((a, b) => b.impact - a.impact);
        distantImpactSystems.sort((a, b) => b.impact - a.impact);
        
        // Log the results for debugging
        console.log(`Found ${directImpactSystems.length} direct impact systems.`);
        console.log(`Found ${secondLevelImpactSystems.length} secondary impact systems.`);
        console.log(`Found ${thirdLevelImpactSystems.length} tertiary impact systems.`);
        console.log(`Found ${distantImpactSystems.length} distant impact systems.`);
        
        return {
            primaryImpact: directImpactSystems,
            secondaryImpact: secondLevelImpactSystems,
            tertiaryImpact: thirdLevelImpactSystems,
            quaternaryImpact: distantImpactSystems,
            criticalityScore,
            recoveryTime: estimateRecoveryTime(directImpactSystems, secondLevelImpactSystems, thirdLevelImpactSystems),
            systemsCount: directImpactSystems.length + secondLevelImpactSystems.length + 
                         thirdLevelImpactSystems.length + distantImpactSystems.length,
            userImpact: estimateUserImpact(directImpactSystems, criticalityScore),
            businessImpact: estimateBusinessImpact(directImpactSystems, secondLevelImpactSystems, systemId, dependencyGraph)
        };
    }
    
    // Generate complete downstream impact paths for all affected systems
    function generateCompleteImpactPaths(sourceSystemId, graph) {
        console.log("Generating complete downstream impact paths from source system:", sourceSystemId);
        
        const allPaths = [];
        let pathId = 1;
        
        // Build a dependency map where:
        // key = systemId
        // value = array of systems that DEPEND ON this system
        const dependentMap = {};
        
        // Initialize with empty arrays for all systems
        Object.keys(graph.nodes).forEach(id => {
            dependentMap[id] = [];
        });
        
        // Populate the dependents map - what systems are affected when a system fails
        // If system A depends on B, then A is affected when B fails
        console.log("Building dependent map...");
        Object.entries(graph.dependencies).forEach(([systemId, dependencies]) => {
            dependencies.forEach(depId => {
                // When B fails, A is impacted
                if (!dependentMap[depId].includes(parseInt(systemId))) {
                    dependentMap[depId].push(parseInt(systemId));
                    console.log(`Added dependent: ${systemId} depends on ${depId}`);
                }
            });
        });
        
        // Also add SSO and hosting relationships to the dependent map
        console.log("Adding SSO relationships to dependent map...");
        Object.entries(graph.ssoRelations).forEach(([systemId, ssoId]) => {
            systemId = parseInt(systemId);
            // If system A has SSO provider B, then A depends on B
            // So when B fails, A is in its dependent list
            if (!dependentMap[ssoId].includes(systemId)) {
                dependentMap[ssoId].push(systemId);
                console.log(`Added SSO dependent: ${systemId} depends on SSO provider ${ssoId}`);
            }
        });
        
        console.log("Adding hosting relationships to dependent map...");
        Object.entries(graph.hostingRelations).forEach(([systemId, hostId]) => {
            systemId = parseInt(systemId);
            // If system A is hosted on B, then A depends on B
            // So when B fails, A is in its dependent list
            if (!dependentMap[hostId].includes(systemId)) {
                dependentMap[hostId].push(systemId);
                console.log(`Added hosting dependent: ${systemId} depends on host ${hostId}`);
            }
        });
        
        // Enhanced approach to generate all possible downstream paths
        // Using DFS to find all paths from the source system to its dependents
        function findAllPaths(startId, visited = new Set(), currentPath = []) {
            // Add current node to path
            currentPath.push(startId);
            
            // Get all immediate dependents of this system
            const dependents = dependentMap[startId] || [];
            
            // If no dependents, this is a leaf node - return the path
            if (dependents.length === 0) {
                // Only return paths with more than just the source node
                return currentPath.length > 1 ? [currentPath] : [];
            }
            
            // Keep track of all paths from this node
            let allPaths = [];
            
            // Visit each dependent and get all paths from there
            for (const depId of dependents) {
                // Skip if already on our current path to avoid cycles
                if (currentPath.includes(depId)) continue;
                
                // Create a new set for this branch to avoid modifying the visited set for other branches
                const newVisited = new Set(visited);
                newVisited.add(depId);
                
                // Find all paths from this dependent
                const pathsFromDep = findAllPaths(depId, newVisited, [...currentPath]);
                
                // Add all found paths to our collection
                allPaths = allPaths.concat(pathsFromDep);
            }
            
            // If no dependent paths found (all were cycles), return just this path
            // if it's longer than 1 node
            if (allPaths.length === 0 && currentPath.length > 1) {
                return [currentPath];
            }
            
            return allPaths;
        }
        
        // Find all paths from the source system
        const paths = findAllPaths(sourceSystemId, new Set([sourceSystemId]));
        console.log(`Found ${paths.length} complete impact paths`);
        
        // Convert paths to the format needed for visualization
        paths.forEach(path => {
            // Skip the path if it only contains the source system
            if (path.length <= 1) return;
            
            // Get the target system (last in the path)
            const targetId = path[path.length - 1];
            const targetSystem = graph.nodes[targetId];
            
            if (!targetSystem) {
                console.warn(`Target system ${targetId} not found in graph nodes`);
                return;
            }
            
            // Determine impact level based on path length (distance from source)
            const distanceFromSource = path.length - 1;
            let impactLevel;
            
            if (distanceFromSource === 1) impactLevel = 'primary';
            else if (distanceFromSource === 2) impactLevel = 'secondary';
            else if (distanceFromSource === 3) impactLevel = 'tertiary';
            else impactLevel = 'quaternary';
            
            // Calculate impact score
            const tierFactor = Math.max(0.1, 1 - ((distanceFromSource - 1) * 0.2));
            const impact = calculateSystemImpact(targetSystem, tierFactor);
            
            // Create connections for visualization
            const connections = [];
            for (let i = 0; i < path.length - 1; i++) {
                const sourceId = path[i];
                const targetId = path[i+1];
                
                // Determine connection type
                let connectionType = 'direct';
                
                // Check if this is an SSO relationship
                if (graph.ssoRelations[targetId] === sourceId) {
                    connectionType = 'sso';
                } 
                // Check if this is a hosting relationship
                else if (graph.hostingRelations[targetId] === sourceId) {
                    connectionType = 'hosting';
                }
                
                connections.push({
                    source: sourceId,
                    target: targetId,
                    type: connectionType
                });
            }
            
            // Map path IDs to system objects
            const pathSystems = path.map(id => graph.nodes[id]);
            
            console.log(`Path ${pathId}: ${path.join(' → ')} [${impactLevel} impact]`);
            
            // Create the impact path object
            allPaths.push({
                id: pathId++,
                targetSystem: {
                    ...targetSystem,
                    impactLevel,
                    impact,
                    distanceFromSource
                },
                path: pathSystems,
                connections: connections,
                length: path.length,
                impactScore: impact
            });
        });
        
        // Sort paths by impact score (descending)
        allPaths.sort((a, b) => b.impactScore - a.impactScore);
        
        console.log(`Processed ${allPaths.length} impact paths for visualization`);
        return allPaths;
    }
    
    // Helper function to get impact level name from level number
    function getImpactLevelName(level) {
        switch(level) {
            case 1: return 'primary';
            case 2: return 'secondary';
            case 3: return 'tertiary';
            default: return 'quaternary'; // Level 4 and beyond
        }
    }
    
    // Helper function to determine the connection type between two systems
    function getConnectionType(sourceId, targetId, graph) {
        // Check if this is an SSO relationship
        if (graph.ssoRelations[targetId] === sourceId) {
            return 'sso';
        }
        // Check if this is a hosting relationship
        if (graph.hostingRelations[targetId] === sourceId) {
            return 'hosting';
        }
        // Default to direct dependency
        return 'direct';
    }
    
    // Calculate impact score for a system based on its properties
    function calculateSystemImpact(system, tierFactor) {
        // Base impact score
        let impact = 5;
        
        // Factor in system category
        switch (system.category.slug) {
            case 'core':
                impact *= 2.0; // Core systems have highest impact
                break;
            case 'integration':
                impact *= 1.5; // Integration systems have high impact
                break;
            case 'custom':
                impact *= 1.2; // Custom systems have medium impact
                break;
            case 'server':
                impact *= 1.8; // Server systems have high-impact
                break;
            case 'external':
                impact *= 1.0; // External systems have standard impact
                break;
        }
        
        // Adjust by tier factor
        impact *= tierFactor;
        
        // Round to integer
        return Math.round(impact);
    }
    
    // Estimate recovery time based on impact data
    function estimateRecoveryTime(primarySystems, secondaryImpactSystems, tertiaryImpactSystems) {
        // Base recovery time in hours
        let recoveryTime = 2;
        
        // Add time based on number of affected systems
        recoveryTime += primarySystems.length * 2; // 2 hours per primary system
        recoveryTime += secondaryImpactSystems.length * 0.8; // 48 minutes per secondary impact system
        recoveryTime += tertiaryImpactSystems.length * 0.3; // 18 minutes per tertiary impact system
        
        // Add complexity factor based on system types
        const hasCore = primarySystems.some(s => s.category.slug === 'core') || 
                      secondaryImpactSystems.some(s => s.category.slug === 'core');
                      
        const hasExternal = primarySystems.some(s => s.category.slug === 'external') || 
                          secondaryImpactSystems.some(s => s.category.slug === 'external');
        
        const hasServer = primarySystems.some(s => s.category.slug === 'server');
        
        if (hasCore) recoveryTime *= 1.5; // Core systems take 50% longer to recover
        if (hasExternal) recoveryTime *= 1.3; // External systems add 30% to recovery time
        if (hasServer) recoveryTime *= 1.8; // Server failures have longest recovery
        
        // Check for SSO or hosting dependencies in primary impact
        const hasSsoProvider = primarySystems.some(s => s.isSsoProvider);
        const hasHostingProvider = primarySystems.some(s => s.isHostingProvider);
        
        if (hasSsoProvider) recoveryTime *= 1.4; // SSO failures are complex to restore
        if (hasHostingProvider) recoveryTime *= 1.7; // Hosting failures take longest to recover
        
        // Round to nearest 0.5 hour
        return Math.round(recoveryTime * 2) / 2;
    }
    
    // Estimate user impact based on impact data
    function estimateUserImpact(primarySystems, criticalityScore) {
        // Calculate user impact based on primary systems and overall criticality
        const totalImpact = primarySystems.reduce((sum, system) => sum + system.impact, 0);
        
        // Include criticality score in assessment
        const combinedScore = totalImpact + (criticalityScore * 0.2);
        
        if (combinedScore > 50 || primarySystems.some(s => s.isSsoProvider)) return "Critical";
        if (combinedScore > 35) return "High";
        if (combinedScore > 20) return "Medium";
        return "Low";
    }
    
    // Estimate business impact based on impact data
    function estimateBusinessImpact(primarySystems, secondaryImpactSystems, systemId, graph) {
        // Business impact categories
        const categories = {
            "Multiple Departments": 3,
            "Cross-Department": 2,
            "Single Department": 1,
            "Limited": 0
        };
        
        // Default to Limited impact
        let impact = "Limited";
        
        // Check if core systems are affected
        if (primarySystems.some(s => s.category.slug === 'core') || 
            secondaryImpactSystems.length > 5) {
            impact = "Multiple Departments";
        } else if (primarySystems.length > 2 || 
                 secondaryImpactSystems.some(s => s.category.slug === 'core')) {
            impact = "Cross-Department";
        } else if (primarySystems.length > 0) {
            impact = "Single Department";
        }
        
        // Special case for SSO or hosting
        if (graph.ssoRelations[systemId] || 
            graph.hostingRelations[systemId] ||
            primarySystems.some(s => s.isSsoProvider || s.isHostingProvider)) {
            // SSO or hosting failures usually affect multiple departments
            impact = "Multiple Departments";
        }
        
        return impact;
    }
    // Update the impact summary on the page
    function updateImpactSummary(impactData) {
        // Update affected systems count
        document.getElementById('total-affected-count').textContent = 
            `${impactData.systemsCount} systems affected`;
        
        // Update the impact progress bar - scale to match the calculated criticality
        const maxCriticality = 100; // Maximum possible criticality score for scaling
        const progressPercentage = Math.min(100, (impactData.criticalityScore / maxCriticality) * 100);
        document.getElementById('impact-progress').style.width = progressPercentage + "%";
        
        // Update recovery metrics
        document.getElementById('systems-affected').textContent = impactData.systemsCount;
        document.getElementById('recovery-time').textContent = 
            impactData.recoveryTime <= 24 ? 
            `${impactData.recoveryTime} hours` : 
            `${Math.round(impactData.recoveryTime / 24)} days`;
        document.getElementById('user-impact').textContent = impactData.userImpact;
        document.getElementById('business-impact').textContent = impactData.businessImpact;
    }
    
    // Update recovery metrics based on impact data
    function updateRecoveryMetrics(systemCategory, impactData) {
        // Update the recovery time display
        document.getElementById('recovery-time').textContent = 
            impactData.recoveryTime <= 24 ? 
            `${impactData.recoveryTime} hours` : 
            `${Math.round(impactData.recoveryTime / 24)} days`;
            
        // Update user impact display
        document.getElementById('user-impact').textContent = impactData.userImpact;
        
        // Update business impact display
        document.getElementById('business-impact').textContent = impactData.businessImpact;
        
        // Update systems affected count
        document.getElementById('systems-affected').textContent = impactData.systemsCount;
    }
    
    // Populate the impact paths section
    function populateImpactPaths(paths) {
        const container = document.getElementById('impact-paths-container');
        if (!container) return;
        
        // Clear existing content
        container.innerHTML = '';
        
        // Update total paths count
        document.getElementById('totalPathsCount').textContent = `${paths.length} paths identified`;
        
        if (!paths || paths.length === 0) {
            container.innerHTML = `
                <div class="empty-state py-8">
                    <svg class="mx-auto h-12 w-12 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    <h3 class="mt-2 text-sm font-medium text-gray-900">No impact paths found</h3>
                    <p class="mt-1 text-sm text-gray-500">
                        No dependency chains were identified in the analysis.
                    </p>
                </div>
            `;
            return;
        }
        
        // Group paths by impact level
        const groupedPaths = {
            primary: paths.filter(p => p.targetSystem.impactLevel === 'primary'),
            secondary: paths.filter(p => p.targetSystem.impactLevel === 'secondary'),
            tertiary: paths.filter(p => p.targetSystem.impactLevel === 'tertiary'),
            quaternary: paths.filter(p => p.targetSystem.impactLevel === 'quaternary')
        };
        
        // Create path items for each group
        ['primary', 'secondary', 'tertiary', 'quaternary'].forEach(level => {
            const levelPaths = groupedPaths[level];
            if (levelPaths.length === 0) return;
            
            const levelTitle = {
                primary: 'Primary Impact Paths (1 hop)',
                secondary: 'Secondary Impact Paths (2 hops)',
                tertiary: 'Tertiary Impact Paths (3 hops)',
                quaternary: 'Distant Impact Paths (4+ hops)'
            }[level];
            
            // Create section header
            const sectionDiv = document.createElement('div');
            sectionDiv.className = `impact-paths-section impact-level-${level}`;
            sectionDiv.innerHTML = `
                <h4 class="text-base font-medium text-gray-900 mb-2">${levelTitle} (${levelPaths.length})</h4>
                <div class="path-items space-y-3" id="path-items-${level}"></div>
            `;
            
            container.appendChild(sectionDiv);
            
            // Add paths to this section
            const pathItemsContainer = sectionDiv.querySelector(`#path-items-${level}`);
            levelPaths.forEach(path => {
                const pathItem = createPathItem(path, level);
                pathItemsContainer.appendChild(pathItem);
            });
        });
        
        // Initial filtering
        filterImpactPaths();
        
        // Re-attach event listeners after dynamically adding path items
        attachDynamicEventListeners();
    }
    
    // Create a path item element
    function createPathItem(path, level) {
        const pathItem = document.createElement('div');
        pathItem.className = `impact-path path-level-${level} path-item`;
        pathItem.setAttribute('data-path-id', path.id);
        pathItem.setAttribute('data-impact-level', level);
        pathItem.setAttribute('data-path-length', path.length);
        pathItem.setAttribute('data-impact-score', path.impactScore);
        pathItem.setAttribute('data-target-system', path.targetSystem.id);
        
        // Track connection types
        const connectionTypes = path.connections.map(c => c.type);
        pathItem.setAttribute('data-connection-types', connectionTypes.join(','));
        
        // Create the header
        const header = document.createElement('div');
        header.className = `impact-path-header path-header-${level} flex justify-between items-center`;
        
        const targetSystem = path.targetSystem;
        
        header.innerHTML = `
            <div>
                <span class="font-medium">${targetSystem.name}</span>
                <span class="ml-2 text-xs px-2 py-0.5 rounded-full" style="background-color: ${targetSystem.category.color}; color: ${targetSystem.category.text_color}">
                    ${targetSystem.category.name}
                </span>
            </div>
            <div class="flex items-center">
                <span class="text-xs mr-3">Path Length: ${path.length-1}</span>
                <span class="text-xs bg-red-100 text-red-800 px-2 py-0.5 rounded-full">
                    Impact Score: ${path.impactScore}
                </span>
            </div>
        `;
        
        pathItem.appendChild(header);
        
        // Create the body with dependency chain
        const body = document.createElement('div');
        body.className = 'impact-path-body';
        
        // Create dependency chain visualization
        const chain = document.createElement('div');
        chain.className = 'dependency-chain';
        
        // Add each system in the path with appropriate styling
        path.path.forEach((system, idx) => {
            // System node
            const systemNode = document.createElement('div');
            systemNode.className = `chain-node`;
            
            // Add special styling based on system type and position
            if (idx === 0) {
                // Source system (the one being analyzed)
                systemNode.style.backgroundColor = '#ffd700';
                systemNode.style.color = '#7c6900';
                systemNode.style.border = '1px solid #ff8c00';
            } else {
                // Affected systems based on level
                if (idx === path.path.length - 1) {
                    // Target system (end of the path)
                    const levelColors = {
                        primary: '#fee2e2',
                        secondary: '#ffedd5',
                        tertiary: '#fef9c3',
                        quaternary: '#dbeafe'
                    };
                    
                    const levelTextColors = {
                        primary: '#b91c1c',
                        secondary: '#c2410c',
                        tertiary: '#854d0e',
                        quaternary: '#0369a1'
                    };
                    
                    const levelBorders = {
                        primary: '#ef4444',
                        secondary: '#f97316',
                        tertiary: '#eab308',
                        quaternary: '#60a5fa'
                    };
                    
                    systemNode.style.backgroundColor = levelColors[targetSystem.impactLevel] || levelColors.quaternary;
                    systemNode.style.color = levelTextColors[targetSystem.impactLevel] || levelTextColors.quaternary;
                    systemNode.style.border = `1px solid ${levelBorders[targetSystem.impactLevel] || levelBorders.quaternary}`;
                } else {
                    // Intermediate node
                    systemNode.style.backgroundColor = '#f3f4f6';
                    systemNode.style.color = '#4b5563';
                    systemNode.style.border = '1px solid #d1d5db';
                }
            }
            
            // Add system name
            systemNode.textContent = system.name;
            
            // Add connection badge if appropriate
            if (idx < path.path.length - 1) {
                const connection = path.connections.find(c => 
                    c.source === system.id && c.target === path.path[idx + 1].id
                );
                
                if (connection && connection.type !== 'direct') {
                    const badge = document.createElement('span');
                    badge.className = `connection-type-badge connection-${connection.type}-badge`;
                    badge.textContent = connection.type === 'sso' ? 'SSO' : 'Hosting';
                    systemNode.appendChild(badge);
                }
            }
            
            chain.appendChild(systemNode);
            
            // Add arrow if not the last system
            if (idx < path.path.length - 1) {
                const arrow = document.createElement('div');
                arrow.className = 'chain-arrow';
                arrow.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                `;
                chain.appendChild(arrow);
            }
        });
        
        body.appendChild(chain);
        
        // Add view in graph button
        const viewButton = document.createElement('div');
        viewButton.className = 'mt-3 text-right';
        viewButton.innerHTML = `
            <button type="button" class="view-path-btn inline-flex items-center px-2.5 py-1.5 border border-gray-300 shadow-sm text-xs font-medium rounded text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" data-path-id="${path.id}" data-target-id="${targetSystem.id}">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                </svg>
                View in Graph
            </button>
        `;
        
        body.appendChild(viewButton);
        pathItem.appendChild(body);
        
        return pathItem;
    }
    
    // Filter and sort impact paths based on user selections
    function filterImpactPaths() {
        const impactLevel = pathTypeFilter ? pathTypeFilter.value : 'all';
        const sortBy = pathSortOrder ? pathSortOrder.value : 'impact';
        const showDirect = showDirectConnections ? showDirectConnections.checked : true;
        const showSSO = showSSOConnections ? showSSOConnections.checked : true;
        const showHosting = showHostingConnections ? showHostingConnections.checked : true;
        
        // Get all path items
        const allPaths = document.querySelectorAll('.path-item');
        
        allPaths.forEach(path => {
            // Get path attributes
            const pathLevel = path.getAttribute('data-impact-level');
            const connectionTypes = path.getAttribute('data-connection-types').split(',');
            
            // Check if this path should be shown based on filters
            let showPath = true;
            
            // Filter by impact level
            if (impactLevel !== 'all' && pathLevel !== impactLevel) {
                showPath = false;
            }
            
            // Filter by connection types
            const hasDirectOnly = connectionTypes.every(type => type === 'direct');
            const hasSSO = connectionTypes.includes('sso');
            const hasHosting = connectionTypes.includes('hosting');
            
            if (
                (!showDirect && hasDirectOnly) ||
                (!showSSO && hasSSO) ||
                (!showHosting && hasHosting)
            ) {
                showPath = false;
            }
            
            // Show/hide this path
            path.style.display = showPath ? 'block' : 'none';
        });
        
        // Sort visible paths
        sortImpactPaths(sortBy);
    }
    
    // Sort impact paths based on sort criteria
    function sortImpactPaths(sortBy) {
        // Get all path sections
        const pathSections = document.querySelectorAll('.impact-paths-section');
        
        pathSections.forEach(section => {
            const pathItemsContainer = section.querySelector('.path-items');
            const pathItems = Array.from(pathItemsContainer.children);
            
            // Sort paths based on criteria
            pathItems.sort((a, b) => {
                if (sortBy === 'impact') {
                    // Sort by impact score (highest first)
                    return parseInt(b.getAttribute('data-impact-score')) - parseInt(a.getAttribute('data-impact-score'));
                } else if (sortBy === 'path-length') {
                    // Sort by path length (shortest first)
                    return parseInt(a.getAttribute('data-path-length')) - parseInt(b.getAttribute('data-path-length'));
                } else if (sortBy === 'alphabetical') {
                    // Sort by system name (A-Z)
                    const nameA = a.querySelector('.impact-path-header').innerText.trim().toLowerCase();
                    const nameB = b.querySelector('.impact-path-header').innerText.trim().toLowerCase();
                    return nameA.localeCompare(nameB);
                }
                return 0;
            });
            
            // Reappend sorted items
            pathItems.forEach(item => {
                pathItemsContainer.appendChild(item);
            });
        });
    }
    
    // Populate the impacted systems by tier
    function populateImpactedSystems(containerId, systems) {
        const container = document.getElementById(containerId);
        
        if (!container) return;
        
        // Clear existing content
        container.innerHTML = '';
        
        if (!systems || systems.length === 0) {
            container.innerHTML = '<div class="p-4 text-sm text-gray-500 text-center">No systems in this impact category</div>';
            return;
        }
        
        // Add each system to the container
        systems.forEach(system => {
            const systemItem = document.createElement('div');
            systemItem.className = 'p-4 hover:bg-gray-50 transition-colors';
            
            let connectionType = '';
            if (system.connectionType === 'sso') {
                connectionType = '<span class="text-xs text-blue-600">SSO</span>';
            } else if (system.connectionType === 'hosting') {
                connectionType = '<span class="text-xs text-purple-600">Hosting</span>';
            }
            
            let sourceInfo = '';
            if (system.sourceNode && system.sourceNode !== {{ system.id }}) {
                // Find the source system name
                const sourceName = dependencyGraph.nodes[system.sourceNode]?.name || 'Unknown System';
                sourceInfo = `<div class="mt-1 text-xs text-gray-500">Dependent on: <a href="#" class="text-blue-600 view-source-btn" data-id="${system.sourceNode}">${sourceName}</a></div>`;
            }
            
            systemItem.innerHTML = `
                <div class="flex justify-between">
                    <div>
                        <h3 class="text-sm font-medium text-gray-900">${system.name}</h3>
                        <div class="flex items-center mt-1 space-x-2">
                            <span class="px-2 py-1 text-xs leading-5 font-semibold rounded-full"
                                style="background-color: ${system.category.color}; color: ${system.category.text_color}">
                                ${system.category.name}
                            </span>
                            ${connectionType ? `<span class="ml-2">${connectionType}</span>` : ''}
                        </div>
                        ${sourceInfo}
                    </div>
                    <div class="flex items-center">
                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                            Impact: ${system.impact}
                        </span>
                    </div>
                </div>
                <p class="mt-2 text-xs text-gray-500">
                    ${system.vendor && system.vendor !== 'Unknown' ? `Vendor: ${system.vendor}` : ''}
                    ${system.status ? `<br>Status: ${system.status.name}` : ''}
                </p>
                <div class="mt-2 text-right">
                    <a href="#" class="text-xs text-blue-600 hover:text-blue-800 view-system-btn" data-id="${system.id}">
                        View in Graph
                    </a>
                </div>
            `;
            
            // Add click handler for "View in Graph" link
            const viewButton = systemItem.querySelector('.view-system-btn');
            if (viewButton) {
                viewButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    highlightSystemInGraph(system.id);
                });
            }
            
            // Add click handler for "View Source" link if present
            const sourceButton = systemItem.querySelector('.view-source-btn');
            if (sourceButton) {
                sourceButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    highlightSystemInGraph(system.sourceNode);
                });
            }
            
            container.appendChild(systemItem);
        });
    }
    
    // Create the dependency graph visualization
    function createDependencyVisualization(systemId, dependencyGraph, impactData) {
       // Force diagram container to be visible
       const container = document.getElementById('diagram-container');
       const disasterGraph = document.getElementById('disaster-graph');
       
       // Make sure container is visible and has width
       if (container.offsetWidth === 0) {
           const parentWidth = container.parentElement.offsetWidth;
           container.style.width = parentWidth ? (parentWidth + 'px') : '100%';
       }
       
       // Ensure the disaster-graph div takes full width
       disasterGraph.style.width = '100%';
       disasterGraph.style.height = '100%';
       
       // Force a layout calculation
       const forceLayout = container.offsetWidth;
       
       const width = Math.max(container.clientWidth, 800); // Use at least 800px
       const height = Math.max(container.clientHeight, 600); // Use at least 600px
       
       // Clear any existing SVG
       d3.select('#disaster-graph').html('');
       
       // Create SVG element
       const svg = d3.select('#disaster-graph')
           .append('svg')
           .attr('width', width)
           .attr('height', height);
           
       // Add a definitions section for markers (arrowheads)
       const defs = svg.append('defs');
       
       // Add arrow marker for regular connections
       defs.append('marker')
           .attr('id', 'arrowhead')
           .attr('viewBox', '0 -5 10 10')
           .attr('refX', 20)
           .attr('refY', 0)
           .attr('markerWidth', 6)
           .attr('markerHeight', 6)
           .attr('orient', 'auto')
           .append('path')
           .attr('d', 'M0,-5L10,0L0,5')
           .attr('fill', '#999');
           
       // Add arrow marker for highlighted connections
       defs.append('marker')
           .attr('id', 'arrowhead-highlighted')
           .attr('viewBox', '0 -5 10 10')
           .attr('refX', 20)
           .attr('refY', 0)
           .attr('markerWidth', 6)
           .attr('markerHeight', 6)
           .attr('orient', 'auto')
           .append('path')
           .attr('d', 'M0,-5L10,0L0,5')
           .attr('fill', '#ff5722');
       
       // Create a group for all elements that will be transformed
       const g = svg.append('g');
       
       // Create graph data structure for D3
       nodes = []; // Use the global nodes array
       const links = [];
       
       // Function to add a system to nodes if not already present
       function addSystemNodeIfNeeded(system) {
           // If provided as a simple ID, convert to object with all necessary properties
           if (typeof system === 'number' || typeof system === 'string') {
               const systemData = dependencyGraph.nodes[system];
               if (!systemData) {
                   console.log(`System ID ${system} not found in dependencyGraph`);
                   return null;
               }
               
               system = {
                   id: parseInt(system),
                   name: systemData.name,
                   category: systemData.category,
                   status: systemData.status,
                   vendor: systemData.vendor
               };
           }
           
           if (!nodes.some(n => n.id === system.id)) {
               const nodeObj = {
                   id: system.id,
                   name: system.name,
                   category: system.category,
                   status: system.status,
                   vendor: system.vendor,
                   impactLevel: system.impactLevel,
                   distanceFromSource: system.distanceFromSource || 0,
                   isSsoProvider: system.isSsoProvider,
                   isHostingProvider: system.isHostingProvider
               };
               
               nodes.push(nodeObj);
               console.log(`Added node: ${system.name} (ID: ${system.id})`);
               return nodeObj;
           }
           
           return nodes.find(n => n.id === system.id);
       }
       
       // Function to add a link between systems if not already present
       function addSystemLinkIfNeeded(sourceId, targetId, type) {
           sourceId = parseInt(sourceId);
           targetId = parseInt(targetId);
           
           // Skip if source or target is missing
           if (!sourceId || !targetId) {
               console.log(`Invalid source or target ID: ${sourceId} -> ${targetId}`);
               return null;
           }
           
           if (!links.some(l => 
               (l.source === sourceId && l.target === targetId) || 
               (l.source.id === sourceId && l.target.id === targetId)
           )) {
               const link = {
                   source: sourceId,
                   target: targetId,
                   type: type || 'direct'
               };
               links.push(link);
               console.log(`Added link: ${sourceId} -> ${targetId} (${type || 'direct'})`);
               return link;
           }
           
           return links.find(l => 
               (l.source === sourceId && l.target === targetId) || 
               (l.source.id === sourceId && l.target.id === targetId)
           );
       }
       
       // Add the central system (the one being analyzed)
       nodes.push({
           id: systemId,
           name: dependencyGraph.nodes[systemId].name,
           category: dependencyGraph.nodes[systemId].category,
           status: dependencyGraph.nodes[systemId].status,
           vendor: dependencyGraph.nodes[systemId].vendor,
           isMainSystem: true,
           distanceFromSource: 0
       });
       
       console.log("Added main system:", dependencyGraph.nodes[systemId].name);
       
       // IMPORTANT: Add ALL systems and connections from completeImpactPaths
       // This ensures that the graph contains the complete downstream paths
       
       console.log(`Adding systems and connections from ${completeImpactPaths.length} impact paths`);
       completeImpactPaths.forEach((path, index) => {
           console.log(`Processing path ${index + 1}: ${path.path.map(s => s.name || s).join(' → ')}`);
           
           // Ensure all systems in the path are added to the nodes array
           path.path.forEach(system => {
               addSystemNodeIfNeeded(system);
           });
           
           // Add all connections in the path
           path.connections.forEach(connection => {
               addSystemLinkIfNeeded(connection.source, connection.target, connection.type);
           });
       });
       
       // Also add nodes and connections from impactData to ensure consistency
       // Primary impact systems
       impactData.primaryImpact.forEach(system => {
           addSystemNodeIfNeeded(system);
           const sourceId = system.sourceNode || systemId;
           addSystemLinkIfNeeded(sourceId, system.id, system.connectionType);
       });
       
       // Secondary impact systems
       impactData.secondaryImpact.forEach(system => {
           addSystemNodeIfNeeded(system);
           const sourceId = system.sourceNode || systemId;
           addSystemLinkIfNeeded(sourceId, system.id, system.connectionType);
       });
       
       // Tertiary impact systems
       impactData.tertiaryImpact.forEach(system => {
           addSystemNodeIfNeeded(system);
           const sourceId = system.sourceNode || systemId;
           addSystemLinkIfNeeded(sourceId, system.id, system.connectionType);
       });
       
       // Quaternary impact systems
       impactData.quaternaryImpact?.forEach(system => {
           addSystemNodeIfNeeded(system);
           const sourceId = system.sourceNode || systemId;
           addSystemLinkIfNeeded(sourceId, system.id, system.connectionType);
       });
       
       console.log(`Visualization will contain ${nodes.length} nodes and ${links.length} links`);
       
       // Set up force simulation
       simulation = d3.forceSimulation(nodes)
           .force('link', d3.forceLink(links).id(d => d.id).distance(100))
           .force('charge', d3.forceManyBody().strength(-500))
           .force('center', d3.forceCenter(width / 2, height / 2))
           .force('collision', d3.forceCollide().radius(30));
       
       // Create links
       const link = g.append('g')
           .selectAll('path')
           .data(links)
           .join('path')
           .attr('class', d => `connection connection-${d.type}`)
           .attr('id', d => `link-${d.source.id || d.source}-${d.target.id || d.target}`)
           .attr('marker-end', 'url(#arrowhead)');
       
       // Create node groups
       const node = g.append('g')
           .selectAll('.node')
           .data(nodes)
           .join('g')
           .attr('class', 'node')
           .attr('id', d => `node-${d.id}`)
           .call(d3.drag()
               .on('start', dragStarted)
               .on('drag', dragged)
               .on('end', dragEnded));
       
       // Add circles to nodes
       node.append('circle')
           .attr('r', d => getNodeRadius(d))
           .attr('data-original-r', d => getNodeRadius(d)) // Store original radius for animations
           .attr('fill', d => getNodeFill(d))
           .attr('stroke', d => getNodeStroke(d))
           .attr('class', 'system-node')
           .on('mouseover', handleNodeMouseOver)
           .on('mouseout', handleNodeMouseOut)
           .on('click', handleNodeClick);
       
       // Add text background rectangles
       const textBg = node.append('rect')
           .attr('class', 'label-background')
           .attr('x', -40)
           .attr('y', d => getNodeRadius(d) + 5)
           .attr('width', 80)
           .attr('height', 16)
           .attr('rx', 3);
       
       // Add text labels
       const text = node.append('text')
           .attr('class', d => `system-label ${d.isMainSystem ? 'main-system' : ''}`)
           .attr('y', d => getNodeRadius(d) + 15)
           .text(d => d.name)
           .each(function(d) {
               // Truncate text if too long
               const textElement = d3.select(this);
               let textContent = d.name;
               
               if (textContent.length > 20) {
                   textContent = textContent.substring(0, 17) + '...';
               }
               
               textElement.text(textContent);
               
               // Update background rectangle size based on text width
               const textWidth = this.getComputedTextLength();
               const paddingX = 4;
               
               d3.select(this.parentNode)
                   .select('rect.label-background')
                   .attr('x', -textWidth/2 - paddingX)
                   .attr('width', textWidth + paddingX * 2);
           });
       
       // Set up zoom behavior
       zoomInstance = d3.zoom()
           .scaleExtent([0.1, 8])
           .on('zoom', event => {
               g.attr('transform', event.transform);
           });
           
       svg.call(zoomInstance);
       
       // Apply connection styles
       updateConnectionStyles();
       
       // Tick function for the force simulation
       simulation.on('tick', () => {
           // Keep nodes within the viewport
           nodes.forEach(node => {
               node.x = Math.max(50, Math.min(width - 50, node.x));
               node.y = Math.max(50, Math.min(height - 50, node.y));
           });
           
           // Update link positions
           link.attr('d', d => {
               const sourceNode = d.source.id ? d.source : nodes.find(n => n.id === d.source);
               const targetNode = d.target.id ? d.target : nodes.find(n => n.id === d.target);
               
               // Skip if node data is not available
               if (!sourceNode || !targetNode) return 'M0,0L0,0';
               
               // Calculate path
               const dx = targetNode.x - sourceNode.x;
               const dy = targetNode.y - sourceNode.y;
               const dr = Math.sqrt(dx * dx + dy * dy);
               
               // Account for node radius
               const sourceRadius = getNodeRadius(sourceNode);
               const targetRadius = getNodeRadius(targetNode);
               
               // Calculate start and end points adjusting for radius
               const angle = Math.atan2(dy, dx);
               const startX = sourceNode.x + sourceRadius * Math.cos(angle);
               const startY = sourceNode.y + sourceRadius * Math.sin(angle);
               const endX = targetNode.x - targetRadius * Math.cos(angle);
               const endY = targetNode.y - targetRadius * Math.sin(angle);
               
               // Create curved path
               return `M${startX},${startY}A${dr*1.2},${dr*1.2} 0 0,1 ${endX},${endY}`;
           });
           
           // Update node positions
           node.attr('transform', d => `translate(${d.x},${d.y})`);
       });
       
       // Show failure path if requested
       if (showFullPaths) {
           setTimeout(() => {
               showFailurePathsInGraph();
           }, 500);
       }
       
       // Apply optimal layout after a short delay
       setTimeout(optimizeLayout, 200);
       
       // Hide loading overlay
       document.querySelector('.loading-overlay').style.display = 'none';
       
       // Expose simulation for later use
       simulation.nodes(nodes);
       this.simulation = simulation;
       
       // Drag handlers
       function dragStarted(event) {
           if (!event.active) simulation.alphaTarget(0.3).restart();
           event.subject.fx = event.subject.x;
           event.subject.fy = event.subject.y;
       }
       
       function dragged(event) {
           event.subject.fx = event.x;
           event.subject.fy = event.y;
       }
       
       function dragEnded(event) {
           if (!event.active) simulation.alphaTarget(0);
           // Keep position fixed to allow manual arrangement
           // event.subject.fx = null;
           // event.subject.fy = null;
       }
       
       // Mouse event handlers
       function handleNodeMouseOver(event, d) {
           // Highlight the node
           d3.select(this).classed('highlighted', true);
           
           // Highlight connected links
           link.each(function(l) {
               if (l.source.id === d.id || l.source === d.id || 
                   l.target.id === d.id || l.target === d.id) {
                   d3.select(this).classed('connection-highlighted', true)
                       .attr('marker-end', 'url(#arrowhead-highlighted)');
               }
           });
           
           // Show info panel
           showInfoPanel(d);
       }
       
       function handleNodeMouseOut(event, d) {
           // Remove highlight if not clicked
           if (!d3.select(this.parentNode).classed('clicked')) {
               d3.select(this).classed('highlighted', false);
               
               // Reset links
               link.each(function(l) {
                   if (!d3.select(this).classed('failure-path')) {
                       d3.select(this)
                           .classed('connection-highlighted', false)
                           .attr('marker-end', 'url(#arrowhead)');
                   }
               });
               
               // Hide info panel if not clicked
               if (!d3.select('.node.clicked').size()) {
                   hideInfoPanel();
               }
           }
       }
       
       function handleNodeClick(event, d) {
           // Reset all nodes
           node.classed('clicked', false)
               .select('circle')
               .classed('highlighted', false);
               
           // Reset all links
           link.each(function() {
               if (!d3.select(this).classed('failure-path')) {
                   d3.select(this)
                       .classed('connection-highlighted', false)
                       .attr('marker-end', 'url(#arrowhead)');
               }
           });
               
           // Highlight this node
           d3.select(this.parentNode).classed('clicked', true);
           d3.select(this).classed('highlighted', true);
           
           // Highlight connected links
           link.each(function(l) {
               if (l.source.id === d.id || l.source === d.id || 
                   l.target.id === d.id || l.target === d.id) {
                   d3.select(this)
                       .classed('connection-highlighted', true)
                       .attr('marker-end', 'url(#arrowhead-highlighted)');
               }
           });
           
           // Show info panel
           showInfoPanel(d);
           
           // If this is the main system and full paths are enabled, show all paths
           if (d.isMainSystem && showFullPaths) {
               showFailurePathsInGraph();
           }
       }
       
       // Function to highlight a specific system in the graph
       window.highlightSystemInGraph = function(systemId) {
           // Find the node element
           const nodeElement = document.getElementById(`node-${systemId}`);
           if (!nodeElement) return;
           
           // Find the D3 data for this node
           const nodeData = nodes.find(n => n.id === parseInt(systemId));
           if (!nodeData) return;
           
           // Trigger click on the node
           handleNodeClick({}, nodeData);
           
           // Center view on this node
           centerOnNode(nodeData);
       };
    }
    
    // Helper: Get node radius based on node type
    function getNodeRadius(node) {
        if (node.isMainSystem) return 30; // Larger main system for emphasis
        if (node.isSsoProvider) return 24; // Larger SSO providers
        if (node.isHostingProvider) return 24; // Larger hosting providers
        
        // Size by impact level and category importance
        let baseSize = 12; // Default size
        
        // Adjust by impact level (closer to source = larger)
        if (node.impactLevel === 'primary') baseSize = 22;
        else if (node.impactLevel === 'secondary') baseSize = 18;
        else if (node.impactLevel === 'tertiary') baseSize = 15;
        else baseSize = 12; // Quaternary+
        
        // Adjust size by system category if available
        if (node.category && node.category.slug) {
            // Core systems are slightly larger
            if (node.category.slug === 'core') baseSize *= 1.15;
            else if (node.category.slug === 'server') baseSize *= 1.1;
        }
        
        return baseSize;
    }
    
    // Helper: Get node fill color based on node type and impact level
    function getNodeFill(node) {
        // Special nodes get special colors
        if (node.isMainSystem) return '#ffd700'; // Gold for main system
        if (node.isSsoProvider) return '#e0f2fe'; // Light blue for SSO provider
        if (node.isHostingProvider) return '#f3e8ff'; // Light purple for hosting provider
        
        // Impact levels
        if (node.impactLevel === 'primary') return '#fee2e2'; // Red bg for primary
        if (node.impactLevel === 'secondary') return '#ffedd5'; // Orange bg for secondary
        if (node.impactLevel === 'tertiary') return '#fef9c3'; // Yellow bg for tertiary
        
        // Use distance to determine opacity for quaternary nodes
        const opacity = node.distanceFromSource ? 
            Math.max(0.5, 1 - ((node.distanceFromSource - 3) * 0.1)) : 0.6;
        
        // For quaternary, return a color with appropriate opacity
        const rgbaColor = `rgba(219, 234, 254, ${opacity})`;
        return rgbaColor;
    }
    
    // Helper: Get node stroke color
    function getNodeStroke(node) {
        // Special nodes
        if (node.isMainSystem) return '#ff8c00'; // Orange stroke for main
        if (node.isSsoProvider) return '#0ea5e9'; // Blue stroke for SSO
        if (node.isHostingProvider) return '#a855f7'; // Purple stroke for hosting
        
        // Impact levels get distinct colors
        if (node.impactLevel === 'primary') return '#ef4444'; // Red for primary
        if (node.impactLevel === 'secondary') return '#f97316'; // Orange for secondary
        if (node.impactLevel === 'tertiary') return '#eab308'; // Yellow for tertiary
        
        // Calculate stroke opacity for distant nodes
        const opacity = node.distanceFromSource ? 
            Math.max(0.6, 1 - ((node.distanceFromSource - 3) * 0.1)) : 0.7;
        
        // Convert to rgba
        return `rgba(96, 165, 250, ${opacity})`; // Blue for quaternary with opacity
    }
    
    // Show complete failure propagation paths
    function showFailurePathsInGraph() {
        // Remove any existing failure paths
        d3.selectAll('.failure-path').remove();
        
        if (!showFullPaths) return;
        
        console.log("Showing failure paths in graph");
        
        // Use completeImpactPaths directly
        if (!completeImpactPaths || completeImpactPaths.length === 0) {
            console.log("No impact paths available to visualize");
            return;
        }
        
        const svg = d3.select('#disaster-graph svg');
        const g = svg.select('g');
        
        console.log(`Visualizing ${completeImpactPaths.length} impact paths`);
        
        // Create a color scale based on impact level
        const impactColorScale = d3.scaleOrdinal()
            .domain(['primary', 'secondary', 'tertiary', 'quaternary'])
            .range(['#ef4444', '#f97316', '#eab308', '#60a5fa']);
        
        // Create a unique visual for each path
        completeImpactPaths.forEach((path, pathIndex) => {
            // Skip paths with just the source system
            if (path.path.length <= 1) {
                console.log("Skipping path with only one node");
                return;
            }
            
            console.log(`Visualizing path ${pathIndex + 1}:`, 
                        path.path.map(s => s.name || s).join(' → '));
            
            // Get the impact level for this path
            const impactLevel = path.targetSystem.impactLevel || 'quaternary';
            const pathColor = impactColorScale(impactLevel);
            
            // Process each connection in the path
            path.connections.forEach((conn, connIndex) => {
                const sourceId = conn.source;
                const targetId = conn.target;
                
                console.log(`  Connection ${connIndex + 1}: ${sourceId} → ${targetId}`);
                
                // Find the link element
                const linkId = `link-${sourceId}-${targetId}`;
                const linkElement = document.getElementById(linkId);
                
                if (!linkElement) {
                    console.warn(`  Link element not found: ${linkId}`);
                    return;
                }
                
                // Get the path data
                const pathData = d3.select(linkElement).attr('d');
                if (!pathData) {
                    console.warn(`  No path data for link: ${linkId}`);
                    return;
                }
                
                // Calculate visual properties based on path length and position in path
                // Shorter paths have higher opacity and width
                const pathLength = path.connections.length;
                const positionFactor = 1 - (connIndex / (pathLength || 1));
                const opacity = 0.7 + (positionFactor * 0.3); // 0.7 to 1.0 opacity
                const width = 2 + (positionFactor * 2); // 2 to 4 px width
                
                // Create failure path visualization
                g.append('path')
                    .attr('d', pathData)
                    .attr('class', 'failure-path')
                    .attr('stroke', pathColor) // Use impact level color
                    .attr('stroke-opacity', opacity)
                    .attr('stroke-width', width)
                    .attr('data-path-index', pathIndex)
                    .attr('data-connection-index', connIndex)
                    .attr('data-source', sourceId)
                    .attr('data-target', targetId)
                    .attr('data-impact-level', impactLevel);
                
                console.log(`  Added failure path visualization for ${sourceId} → ${targetId}`);
            });
        });
        
        // Ensure highlighted paths are properly layered (higher levels on top)
        g.selectAll('.failure-path')
            .sort((a, b) => {
                const aImpact = d3.select(a).attr('data-impact-level');
                const bImpact = d3.select(b).attr('data-impact-level');
                const impactOrder = { 'primary': 3, 'secondary': 2, 'tertiary': 1, 'quaternary': 0 };
                return impactOrder[aImpact] - impactOrder[bImpact];
            });
        
        console.log(`Added ${d3.selectAll('.failure-path').size()} failure path visualizations`);
    }
    
    // Update link opacity and stroke width based on connection type
    function updateConnectionStyles() {
        // For the links
        d3.selectAll('.connection')
            .attr('stroke-width', function(d) {
                // Determine tier level from target node
                const targetNode = d.target.id ? d.target : nodes.find(n => n.id === d.target);
                const sourceNode = d.source.id ? d.source : nodes.find(n => n.id === d.source);
                
                if (!targetNode) return 1.5;
                
                // Highlight links connected to main system
                if (sourceNode && sourceNode.isMainSystem) {
                    return 3; // Make direct connections from main system thicker
                }
                
                const level = targetNode.impactLevel;
                
                // Adjust width based on connection type as well
                let baseWidth = 1.5;
                if (level === 'primary') baseWidth = 2.5;
                else if (level === 'secondary') baseWidth = 2;
                else if (level === 'tertiary') baseWidth = 1.5;
                else baseWidth = 1; // Quaternary+
                
                // Make SSO and hosting connections slightly thinner
                if (d.type === 'sso') return baseWidth * 0.9;
                if (d.type === 'hosting') return baseWidth * 0.8;
                
                return baseWidth;
            })
            .attr('stroke-opacity', function(d) {
                // Determine tier level from target node
                const targetNode = d.target.id ? d.target : nodes.find(n => n.id === d.target);
                const sourceNode = d.source.id ? d.source : nodes.find(n => n.id === d.source);
                
                if (!targetNode) return 0.6;
                
                // Highlight links connected to main system
                if (sourceNode && sourceNode.isMainSystem) {
                    return 1.0; // Make direct connections from main system fully visible
                }
                
                const level = targetNode.impactLevel;
                
                // Direct connections more visible
                let baseOpacity = 0.4;
                if (level === 'primary') baseOpacity = 0.8;
                else if (level === 'secondary') baseOpacity = 0.7;
                else if (level === 'tertiary') baseOpacity = 0.6;
                else baseOpacity = 0.4; // Quaternary+
                
                // Adjust opacity based on connection type too
                if (d.type === 'sso') return baseOpacity * 0.9;
                if (d.type === 'hosting') return baseOpacity * 0.8;
                
                return baseOpacity;
            })
            .attr('stroke-dasharray', function(d) {
                // Use different dash patterns for different connection types
                if (d.type === 'sso') return '5, 3'; // Dashed line for SSO
                if (d.type === 'hosting') return '1, 3'; // Dotted line for hosting
                return 'none'; // Solid line for direct dependencies
            });
    }
    
    // Function to highlight a specific path in the graph
    function highlightPathInGraph(pathId, targetSystemId) {
        // Find the path data
        const path = completeImpactPaths.find(p => p.id === parseInt(pathId));
        if (!path) return;
        
        // Reset all highlights
        resetView();
        
        // Clear any existing failure paths
        d3.selectAll('.failure-path').remove();
        
        // Get the SVG group
        const svg = d3.select('#disaster-graph svg');
        const g = svg.select('g');
        
        // Create a unique path visualization
        const nodeIds = path.path.map(node => node.id || node);
        
        // Set other nodes to low opacity
        d3.selectAll('.node').style('opacity', 0.3);
        
        // Highlight each node in the path
        nodeIds.forEach((nodeId, index) => {
            const nodeElement = document.getElementById(`node-${nodeId}`);
            if (nodeElement) {
                // Set to full opacity
                d3.select(nodeElement).style('opacity', 1);
                
                // Apply special highlighting to the node
                if (index === 0) {
                    // Source node
                    d3.select(nodeElement).select('circle')
                        .classed('highlighted', true)
                        .style('stroke-width', '3px');
                } else if (index === nodeIds.length - 1) {
                    // Target node (end of path)
                    d3.select(nodeElement).classed('clicked', true);
                    d3.select(nodeElement).select('circle')
                        .classed('highlighted', true)
                        .style('stroke-width', '3px');
                    
                    // Add pulsing animation to target node
                    const circle = d3.select(nodeElement).select('circle');
                    const originalRadius = parseFloat(circle.attr('r'));
                    
                    circle.transition()
                        .duration(800)
                        .attr('r', originalRadius * 1.2)
                        .transition()
                        .duration(800)
                        .attr('r', originalRadius)
                        .on('end', function repeat() {
                            d3.select(this)
                                .transition()
                                .duration(800)
                                .attr('r', originalRadius * 1.2)
                                .transition()
                                .duration(800)
                                .attr('r', originalRadius)
                                .on('end', repeat);
                        });
                } else {
                    // Intermediate nodes
                    d3.select(nodeElement).select('circle')
                        .classed('highlighted', true)
                        .style('stroke-width', '2px');
                }
            }
        });
        
        // Set all connections to low opacity
        d3.selectAll('.connection').style('opacity', 0.2);
        
        // Determine path color based on impact level
        const impactLevel = path.targetSystem.impactLevel || 'quaternary';
        const pathColorMap = {
            'primary': '#ef4444',    // red
            'secondary': '#f97316',  // orange
            'tertiary': '#eab308',   // yellow
            'quaternary': '#60a5fa'  // blue
        };
        const pathColor = pathColorMap[impactLevel];
        
        // Create highlighted connections for each segment of the path
        for (let i = 0; i < path.connections.length; i++) {
            const connection = path.connections[i];
            const sourceId = connection.source;
            const targetId = connection.target;
            
            // Find the existing link element
            const linkId = `link-${sourceId}-${targetId}`;
            const existingLink = document.getElementById(linkId);
            
            if (!existingLink) continue;
            
            // Get the path data
            const pathData = d3.select(existingLink).attr('d');
            if (!pathData) continue;
            
            // Make the original connection fully visible
            d3.select(existingLink)
                .style('opacity', 1)
                .classed('connection-highlighted', true)
                .attr('marker-end', 'url(#arrowhead-highlighted)');
            
            // Calculate position factor (start is thicker/more opaque than end)
            const pathLength = path.connections.length;
            const positionFactor = 1 - (i / (pathLength || 1));
            
            // Create the failure path element with animated dash array for flowing effect
            g.append('path')
                .attr('d', pathData)
                .attr('class', 'failure-path')
                .attr('stroke', pathColor)
                .attr('stroke-opacity', 0.8 + (positionFactor * 0.2))
                .attr('stroke-width', 3 + (positionFactor * 2))
                .attr('stroke-dasharray', '4,2')
                .attr('data-path-index', pathId)
                .attr('data-impact-level', impactLevel);
        }
        
        // Focus on the target system
        if (targetSystemId) {
            const targetNode = nodes.find(n => n.id === parseInt(targetSystemId));
            if (targetNode) {
                // Center view on target node
                centerOnNode(targetNode);
                
                // Show info panel for target node
                showInfoPanel(targetNode);
            }
        }
        
        // Add animation to make the path "flow"
        // This creates a moving dashed line effect along the path
        d3.selectAll('.failure-path')
            .style('animation', 'dashOffset 30s linear infinite');
            
        // Add a style for the animation if it doesn't exist
        if (!document.getElementById('dash-animation-style')) {
            const style = document.createElement('style');
            style.id = 'dash-animation-style';
            style.textContent = `
                @keyframes dashOffset {
                    from {
                        stroke-dashoffset: 0;
                    }
                    to {
                        stroke-dashoffset: 100;
                    }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    // Reset view
    function resetView() {
        // Clear any highlighting
        d3.selectAll('.node').classed('clicked', false);
        d3.selectAll('.system-node').classed('highlighted', false);
        d3.selectAll('.connection')
            .classed('connection-highlighted', false)
            .attr('marker-end', 'url(#arrowhead)');
        
        // Remove failure paths
        d3.selectAll('.failure-path').remove();
        
        // Reset simulation
        if (simulation) {
            simulation.alpha(0.3).restart();
        }
        
        // Reset zoom
        const svg = d3.select('#disaster-graph svg');
        svg.transition().duration(750).call(
            zoomInstance.transform, d3.zoomIdentity
        );
        
        // Set normal opacity for all nodes
        d3.selectAll('.node').style('opacity', 1);
        
        // Apply standard connection styling
        updateConnectionStyles();
        
        // Stop any animations
        d3.selectAll('.system-node').interrupt();
        
        // Reset to original radius
        d3.selectAll('.system-node').each(function(d) {
            const originalRadius = d3.select(this).attr('data-original-r');
            d3.select(this).attr('r', originalRadius);
        });
        
        // Hide info panel
        hideInfoPanel();
    }
    
    // Function to show immediate impacts
    function showImmediateImpacts() {
        console.log("Showing immediate impacts");
        
        // Hide the failure paths first
        d3.selectAll('.failure-path').remove();
        
        // Focus on primary impacts
        d3.selectAll('.node').each(function(d) {
            if (d) {
                if (d.impactLevel === 'primary') {
                    d3.select(this).style('opacity', 1);
                    
                    // Add pulsing animation to primary impact nodes
                    const circle = d3.select(this).select('circle');
                    
                    // Store original radius
                    const originalRadius = parseFloat(circle.attr('r'));
                    
                    // Add pulsing animation
                    circle.transition()
                        .duration(800)
                        .attr('r', originalRadius * 1.2)
                        .transition()
                        .duration(800)
                        .attr('r', originalRadius)
                        .on('end', function repeat() {
                            d3.select(this)
                                .transition()
                                .duration(800)
                                .attr('r', originalRadius * 1.2)
                                .transition()
                                .duration(800)
                                .attr('r', originalRadius)
                                .on('end', repeat);
                        });
                    
                } else if (d.isMainSystem) {
                    d3.select(this).style('opacity', 1);
                } else {
                    d3.select(this).style('opacity', 0.2);
                }
            }
        });
        
        // Only show connections to primary impacts
        d3.selectAll('.connection').each(function(d) {
            if (d && d.target) {
                const targetNode = d.target.id ? d.target : nodes.find(n => n.id === d.target);
                const sourceNode = d.source.id ? d.source : nodes.find(n => n.id === d.source);
                
                if ((targetNode && targetNode.impactLevel === 'primary') || 
                    (sourceNode && sourceNode.isMainSystem)) {
                    d3.select(this).style('opacity', 0.8).attr('stroke-width', 3);
                } else {
                    d3.select(this).style('opacity', 0.1);
                }
            }
        });
    }
    
    // Toggle showing full failure paths
    function toggleFullPath() {
        showFullPaths = !showFullPaths;
        
        // Update button text and style
        const button = document.getElementById('showFullPathButton');
        if (showFullPaths) {
            button.classList.add('active');
            showFailurePathsInGraph();
        } else {
            button.classList.remove('active');
            d3.selectAll('.failure-path').remove();
        }
    }
    
    // Toggle hiding intermediate nodes
    function toggleIntermediate() {
        hideIntermediateNodes = !hideIntermediateNodes;
        
        // Update button state
        const button = document.getElementById('toggleIntermediateButton');
        if (hideIntermediateNodes) {
            button.classList.add('active');
            
            // Hide tertiary and quaternary impact nodes
            d3.selectAll('.node').each(function(d) {
                if (d && (d.impactLevel === 'tertiary' || d.impactLevel === 'quaternary')) {
                    d3.select(this).style('opacity', 0.15);
                } else if (d && d.impactLevel === 'secondary') {
                    // Dim secondary a bit too
                    d3.select(this).style('opacity', 0.5);
                }
            });
            
            // Hide links to tertiary and quaternary impact nodes
            d3.selectAll('.connection').each(function(d) {
                if (d && d.target) {
                    const targetNode = d.target.id ? d.target : nodes.find(n => n.id === d.target);
                    if (targetNode && (targetNode.impactLevel === 'tertiary' || targetNode.impactLevel === 'quaternary')) {
                        d3.select(this).style('opacity', 0.15);
                    } else if (targetNode && targetNode.impactLevel === 'secondary') {
                        // Dim secondary a bit too
                        d3.select(this).style('opacity', 0.3);
                    }
                }
            });
        } else {
            button.classList.remove('active');
            
            // Show all nodes with appropriate opacity based on level
            d3.selectAll('.node').each(function(d) {
                if (d && d.impactLevel === 'quaternary') {
                    d3.select(this).style('opacity', 0.8);
                } else {
                    d3.select(this).style('opacity', 1);
                }
            });
            
            // Apply standard connection styling
            updateConnectionStyles();
        }
    }
    
    // Toggle showing hosting dependencies
    function toggleHosting() {
        showHostingDependencies = !showHostingDependencies;
        
        // Update button state
        const button = document.getElementById('toggleHostingButton');
        if (showHostingDependencies) {
            button.classList.add('active');
            
            // Show hosting links
            d3.selectAll('.connection-hosting').style('opacity', 0.6);
            
            // Show hosting provider nodes
            d3.selectAll('.node').each(function(d) {
                if (d && d.isHostingProvider) {
                    d3.select(this).style('opacity', 1);
                }
            });
        } else {
            button.classList.remove('active');
            
            // Hide hosting links
            d3.selectAll('.connection-hosting').style('opacity', 0.2);
            
            // Fade hosting provider nodes (unless highlighted)
            d3.selectAll('.node').each(function(d) {
                if (d && d.isHostingProvider && !d3.select(this).classed('clicked')) {
                    d3.select(this).style('opacity', 0.3);
                }
            });
        }
    }
    
    // Toggle showing SSO dependencies
    function toggleSso() {
        showSsoDependencies = !showSsoDependencies;
        
        // Update button state
        const button = document.getElementById('toggleSsoButton');
        if (showSsoDependencies) {
            button.classList.add('active');
            
            // Show SSO links
            d3.selectAll('.connection-sso').style('opacity', 0.6);
            
            // Show SSO provider nodes
            d3.selectAll('.node').each(function(d) {
                if (d && d.isSsoProvider) {
                    d3.select(this).style('opacity', 1);
                }
            });
        } else {
            button.classList.remove('active');
            
            // Hide SSO links
            d3.selectAll('.connection-sso').style('opacity', 0.2);
            
            // Fade SSO provider nodes (unless highlighted)
            d3.selectAll('.node').each(function(d) {
                if (d && d.isSsoProvider && !d3.select(this).classed('clicked')) {
                    d3.select(this).style('opacity', 0.3);
                }
            });
        }
    }
    
    // Zoom in
    function zoomIn() {
        const svg = d3.select('#disaster-graph svg');
        
        svg.transition().duration(300).call(
            zoomInstance.scaleBy, 1.5
        );
    }
    
    // Zoom out
    function zoomOut() {
        const svg = d3.select('#disaster-graph svg');
        
        svg.transition().duration(300).call(
            zoomInstance.scaleBy, 0.667
        );
    }
    
    // Fit all nodes within view
    function fitAllNodes() {
        if (!simulation) return;
        
        const svg = d3.select('#disaster-graph svg');
        const width = parseInt(svg.attr('width'));
        const height = parseInt(svg.attr('height'));
        
        // Get bounds of all nodes
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        
        simulation.nodes().forEach(node => {
            minX = Math.min(minX, node.x || 0);
            maxX = Math.max(maxX, node.x || 0);
            minY = Math.min(minY, node.y || 0);
            maxY = Math.max(maxY, node.y || 0);
        });
        
        // Add padding
        const padding = 80;
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;
        
        // Calculate scale to fit
        const dx = maxX - minX;
        const dy = maxY - minY;
        const scale = Math.min(width / dx, height / dy, 1.5); // Use no more than 1.5x zoom
        
        // Calculate center of the bounding box
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        
        // Create transform
        const transform = d3.zoomIdentity
            .translate(width/2 - centerX * scale, height/2 - centerY * scale)
            .scale(scale);
            
        // Apply transform with animation
        svg.transition()
            .duration(750)
            .call(zoomInstance.transform, transform);
    }
    
    // Center the view on a specific node
    function centerOnNode(node) {
        const scale = 1.5; // Zoom in a bit when centering
        const svg = d3.select('#disaster-graph svg');
        const width = parseInt(svg.attr('width'));
        const height = parseInt(svg.attr('height'));
        
        const transform = d3.zoomIdentity
            .translate(width/2 - node.x * scale, height/2 - node.y * scale)
            .scale(scale);
        
        svg.transition()
            .duration(750)
            .call(zoomInstance.transform, transform);
    }
    
    // Apply optimal layout
    function optimizeLayout() {
        if (!simulation) return;
        
        console.log("Applying optimized layout...");
        
        // Find the central node
        const centralNode = simulation.nodes().find(n => n.isMainSystem);
        if (!centralNode) return;
        
        // Get the diagram dimensions
        const width = parseInt(d3.select('#disaster-graph svg').attr('width'));
        const height = parseInt(d3.select('#disaster-graph svg').attr('height'));
        
        // Place central node in the middle
        centralNode.fx = width / 2;
        centralNode.fy = height / 2;
        
        // Group nodes by level
        const primaryNodes = simulation.nodes().filter(n => n.impactLevel === 'primary');
        const secondaryNodes = simulation.nodes().filter(n => n.impactLevel === 'secondary');
        const tertiaryNodes = simulation.nodes().filter(n => n.impactLevel === 'tertiary');
        const quaternaryNodes = simulation.nodes().filter(n => n.impactLevel === 'quaternary');
        
        console.log(`Layout: Found ${primaryNodes.length} primary, ${secondaryNodes.length} secondary, ${tertiaryNodes.length} tertiary, and ${quaternaryNodes.length} quaternary nodes`);
        
        // Calculate radii for each level - adjusted based on node count in each level
        const baseRadius = Math.min(width, height) * 0.35; // Ensure it fits within smaller dimension
        const levelCount = [primaryNodes.length, secondaryNodes.length, tertiaryNodes.length, quaternaryNodes.length];
        const maxNodesInLevel = Math.max(...levelCount);
        
        // Adjust spacing based on level population
        const primaryRadius = baseRadius * 0.3;
        const secondaryRadius = baseRadius * 0.55;
        const tertiaryRadius = baseRadius * 0.75;
        const quaternaryRadius = baseRadius * 0.95;
        
        // Layout primary nodes in a circle around central node
        arrangeNodesInCircle(primaryNodes, centralNode, primaryRadius, 0);
        
        // Layout secondary nodes in a wider circle
        arrangeNodesInCircle(secondaryNodes, centralNode, secondaryRadius, primaryNodes.length * 0.2);
        
        // Layout tertiary nodes in the next circle
        arrangeNodesInCircle(tertiaryNodes, centralNode, tertiaryRadius, secondaryNodes.length * 0.1);
        
        // Layout quaternary nodes in the outermost circle
        arrangeNodesInCircle(quaternaryNodes, centralNode, quaternaryRadius, tertiaryNodes.length * 0.05);
        
        // Helper function for circular arrangement with offset
        function arrangeNodesInCircle(nodes, centerNode, radius, angleOffset) {
            // Skip if no nodes to arrange
            if (!nodes.length) return;
            
            // Sort nodes to ensure consistent layout - use system ID for determinism
            nodes.sort((a, b) => a.id - b.id);
            
            // Arrange nodes in a circle
            const angleBetweenNodes = (2 * Math.PI) / nodes.length;
            
            nodes.forEach((node, i) => {
                // Calculate angle with offset for better distribution
                const angle = (i * angleBetweenNodes) + (angleOffset * (Math.PI / 180));
                
                // Set fixed position
                node.fx = centerNode.fx + radius * Math.cos(angle);
                node.fy = centerNode.fy + radius * Math.sin(angle);
                
                // Add a small random offset to avoid perfect circles
                const randomOffset = Math.random() * 5;
                node.fx += randomOffset * Math.cos(angle + Math.PI/4);
                node.fy += randomOffset * Math.sin(angle + Math.PI/4);
                
                // Ensure node stays within bounds
                node.fx = Math.max(50, Math.min(width - 50, node.fx));
                node.fy = Math.max(50, Math.min(height - 50, node.fy));
            });
        }
        
        // Restart simulation with a bit of force to settle the layout
        simulation.alpha(0.3).restart();
        
        // Apply consistent connection styles
        updateConnectionStyles();
        
        // Fit all nodes into view
        setTimeout(fitAllNodes, 500);
        
        console.log("Layout optimization complete.");
    }
    
    // Show info panel for a node with enhanced content
    function showInfoPanel(node) {
        const panel = document.getElementById('infoPanel');
        const title = document.getElementById('infoPanelTitle');
        const content = document.getElementById('infoPanelContent');
        
        // Set title
        title.textContent = node.name;
        
        // Build content HTML
        let html = '<div class="space-y-3">';
        
        // Add impact level if applicable
        if (node.impactLevel) {
            let badgeClass;
            let impactText;
            
            switch(node.impactLevel) {
                case 'primary':
                    badgeClass = 'bg-red-100 text-red-800';
                    impactText = 'Primary Impact';
                    break;
                case 'secondary':
                    badgeClass = 'bg-orange-100 text-orange-800';
                    impactText = 'Secondary Impact';
                    break;
                case 'tertiary':
                    badgeClass = 'bg-yellow-100 text-yellow-800';
                    impactText = 'Tertiary Impact';
                    break;
                case 'quaternary':
                    const distanceText = node.distanceFromSource >= 4 ? 
                        ` (Level ${node.distanceFromSource})` : '';
                    badgeClass = 'bg-blue-100 text-blue-800';
                    impactText = `Distant Impact${distanceText}`;
                    break;
                default:
                    badgeClass = 'bg-gray-100 text-gray-800';
                    impactText = 'Unknown Impact';
            }
            
            html += `
                <div class="flex flex-wrap gap-2">
                    <span class="px-2 py-1 text-xs leading-5 font-semibold rounded-full ${badgeClass}">
                        ${impactText}
                    </span>
            `;
            
            // Add distance badge if applicable
            if (node.distanceFromSource) {
                html += `
                    <span class="px-2 py-1 text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">
                        ${node.distanceFromSource} hop${node.distanceFromSource !== 1 ? 's' : ''} from source
                    </span>
                `;
            }
            
            html += `</div>`;
        }
        
        // Add category
        if (node.category) {
            html += `<p><strong>Category:</strong> <span style="background-color: ${node.category.color}; color: ${node.category.text_color}; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem;">${node.category.name}</span></p>`;
        }
        
        // Add status
        if (node.status) {
            html += `<p><strong>Status:</strong> <span style="background-color: ${node.status.color}; color: ${node.status.text_color}; padding: 2px 6px; border-radius: 4px; font-size: 0.8rem;">${node.status.name}</span></p>`;
        }
        
        // Add vendor if available
        if (node.vendor && node.vendor !== 'Unknown') {
            html += `<p><strong>Vendor:</strong> ${node.vendor}</p>`;
        }
        
        // Add special role indicators
        if (node.isMainSystem) {
            html += `<p class="flex items-center"><svg class="h-4 w-4 mr-1 text-amber-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg> <span class="text-amber-600 font-semibold">System Under Analysis</span></p>`;
        } else if (node.isSsoProvider) {
            html += `<p class="flex items-center"><svg class="h-4 w-4 mr-1 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg> <span class="text-blue-600 font-semibold">SSO Provider</span></p>`;
        } else if (node.isHostingProvider) {
            html += `<p class="flex items-center"><svg class="h-4 w-4 mr-1 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" /></svg> <span class="text-purple-600 font-semibold">Hosting Provider</span></p>`;
        }
        
        // Add connection info if it has a source node
        if (node.sourceNode && node.sourceNode !== {{ system.id }}) {
            const sourceName = dependencyGraph.nodes[node.sourceNode]?.name || 'Unknown System';
            const connectionType = node.connectionType || 'direct';
            
            let connectionIcon = '';
            let connectionColor = '';
            
            if (connectionType === 'sso') {
                connectionIcon = '<svg class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>';
                connectionColor = 'text-blue-600';
            } else if (connectionType === 'hosting') {
                connectionIcon = '<svg class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" /></svg>';
                connectionColor = 'text-purple-600';
            } else {
                connectionIcon = '<svg class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" /></svg>';
                connectionColor = 'text-gray-600';
            }
            
            html += `
                <div class="mt-2 pt-2 border-t border-gray-200">
                    <p class="flex items-center ${connectionColor}">
                        ${connectionIcon}
                        <span class="font-medium">${connectionType.charAt(0).toUpperCase() + connectionType.slice(1)} Dependency:</span>
                    </p>
                    <p class="mt-1 ml-5">Depends on <a href="#" class="text-blue-600 view-source-btn" data-id="${node.sourceNode}">${sourceName}</a></p>
                </div>
            `;
        }
        
        html += `<div class="mt-3 pt-3 border-t border-gray-200">
            <a href="/systems/${node.id}/" class="flex items-center text-blue-600 hover:underline">
                <svg class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                </svg>
                View System Details
            </a>
        </div>`;
        
        html += '</div>';
        
        // Set content
        content.innerHTML = html;
        
        // Add event listener to the view source button
        const sourceButton = content.querySelector('.view-source-btn');
        if (sourceButton) {
            sourceButton.addEventListener('click', function(e) {
                e.preventDefault();
                const sourceId = this.getAttribute('data-id');
                highlightSystemInGraph(sourceId);
            });
        }
        
        // Show panel
        panel.style.display = 'block';
    }
    
    // Hide info panel
    function hideInfoPanel() {
        const panel = document.getElementById('infoPanel');
        panel.style.display = 'none';
    }
});
</script>
{% endblock %}